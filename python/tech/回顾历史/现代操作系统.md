# 现代操作系统

## 引论

计算机安装了一层软件,称为**操作系统**.它的任务是为用户程序提供一个更好,更简单,更清晰的计算机模型,并管理处理器,主存,磁盘等设备.

计算有两种运行模式:*用户态*和*内核态*.内核态下操作系统拥有全部硬件的访问权,可以运行机器能够运行的任何指令;用户态下,只能使用指令的一个子集.

shell或者GUI处于用户态的最低层次.

在内核态运行的一定是操作系统的一部分,但是内核态外运行的程序也有争议的被认为是操作系统的一部分

### 1.1什么是操作系统

操作系统执行两个基本独立的任务:为应用程序员提供一个资源集的清晰抽象,并管理这些硬件资源.

#### 作为扩展机器的操作系统

抽象是管理复杂性的一个关键.第一对抽象进行定义和实现,第二随时使用这些抽象解决问题.操作系统的任务是创建好的抽象,并事项和管理它所创建的抽象对象.**理解抽象是理解操作系统的关键**

抽象分为:有关抽象的定义和实现;随时用这些抽象解决问题

操作系统的任务是创建好的抽象,并实现和管理它所创建的抽象对象

操作系统的实际客户是应用程序,它们直接与操作系统及其抽象打交道.

#### 作为资源管理器的操作系统

自顶向下的角度看:操作系统是想应用程序提供基本抽象的概念;自底向上的角度看:操作系统的任务是在互相竞争的程序之间有序的控制对处理器,存储器以及其他I/O接口设备的分配.

资源管理有两种方式:**时间上服用**和**空间上服用**

*时间上复用*:不同程序轮流使用资源

*空间上复用*:每个客户得到资源的一部分

### 1.2操作系统历史

批处理(没有实时交互)-->分时系统(快速响应)-->MULTIC-->PDP-->UNIX(PDP-7){主要有两个分支Sysytem V和BSD},MINIX(1987)--Linux

intel 8080(1974) IBM+Gates(DOS(Seattle Computer Producer))-->MSDOS(1985~1995)--> Windows 95(1995)-->windows 98(1998)-->windows 2000(1999){NT 4.0-->NT 5.0}-->XP(2001)

intel 80286(1983)

Steve Jobs --> Lisa -->Macintosh(来自于FreeBSD<--BSD)

Unix上都有X11(由MIT开发)Gnome和KDE都在X11之上开发

### 1.3 计算机硬件

现代计算机包含多重总线

#### 处理器

每个CPU周期中,首先从内存取指令,解码以确定类型和操作数,接着执行之,取址->解码->执行->取址...

从内存取数据比执行指令耗时大得多-->CPU内部设置寄存器用来保存临时数据或关键变量-->提供指令将数据从内存存入寄存器,或者将寄存器数据存入内存.

还有对程序员可见的专门寄存器,例如
- *程序计数器*,保存了下一条指令的内存地址
- *堆栈指针*:指向内存中当前栈的顶端.栈中含有已经进入但是还没有退出的每个过程的一个框架.在一个过程的堆栈框架中保存了有关的输入参数,局部变量,以及那些没有保存在寄存器中的临时变量
- *程序状态字(PSW)*:包含条件码位(由比较指令设置),CPU优先级,模式(用户态或者内核态).用户通常读入整PSW,只对其中少量的字段写入.在系统调用和 I/O 中,PSW的作用很重要

在时间服用CPU中操作系统在终止某个程序并启动另一个程序时,必须保存所有的寄存器.

用户态下,想要从操作系统获得服务,用户程序必须使用系统调用.系统调用是的操作系统进入内核态.*TRAP*指令用于把用户态切换到内核态,并启用操作系统.

#### 存储器

寄存器-->高速缓存(L1无时延,L2 1到2个时钟周期)-->内存(耗时较大)-->磁盘

高速缓存命中需要两个始终周期,访问内存需要大量的时间.

多核处理器,考虑缓存时共享还是独立,共享需要更复杂的缓存控制器,独立时需要保持缓存一致.

#### 磁盘

扇区-->磁道-->柱面

#### I/O设备

I/O设备一般包含两个部分:设备控制器和设备本身

由于设备接口隐藏在控制器中,所以,操作系统看到的是对控制器的接口.

每类控制器需要不同的软件(**设备驱动程序**)进行控制

设备驱动程序装入到操作系统中,热插拔设备需要动态的装载设备驱动程序

每个设备控制器都有少量的用于通信的寄存器.*所有设备寄存器的集合构成了I/O端口空间*

设备寄存器可以映射为操作系统的地址空间,这样可以像普通存储器一样读出和写入,不需要专门的I/O指令.或者,设备寄存器放入一个专门的I/O端口空间中,每个寄存器都有一个端口地址.在内核态中使用专门的IN和OUT指令,设备驱动程序调用该指令读写这些寄存器.两种方式都广泛被使用


##### 实现输入输出的三种方式

第一种

*忙等待* 设备驱动程序启动I/O并在一个连续不断的循环中检查该设备是否完成工作.当I/O结束后,设备驱动程序把数据送到指定的地方,并返回,然后操作系统将控制返回给调用者

第二种

*中断* 设备驱动程序启动设备并且让改设备在操作完成时发出一个中断-->设备驱动程序在这个时刻返回-->操作系统接着在需要时阻塞调用者并安排其他工作进行-->当设备驱动程序检测到该设备完成时,他发出一个中断通知操作系统.

![中断](./src/现代操作系统/中断1.png)
1. 设备驱动程序通过写设备寄存器通知设备控制器做什么
2. 使用特定的总线发信号给中断控制器芯片(如果中断控制器已经准备好接受中断,如果忙于一个更高级的中断,可能不接受)
3. 在CPU芯片的一个管脚上声明
4. 中断控制器将设备的编号放到总线上,这样CPU可以读总线,并且知道哪一个设备刚刚完成了操作

![中断处理程序](./src/现代操作系统/中断2.png)
一旦CPU决定取中断,通常程序计数器和PSW就被压入当前堆栈中,并且CPU被切换到用户态.设备编号可以成为部分内存的一个引用,用于寻找改设备中断处理程序的地址,这部分内存被称为**中断向量**.
1. 当中断处理程序(中断设备的设备驱动程序的一部分)开始后,它取走已入栈的程序计数器和PSW,并保存之,然后查询设备的状态
2. 当中断处理程序全部完成之后,它返回到先前运行的用户程序中尚未执行的头一条指令

第三种

为I/O使用一种特殊的直接存储器访问(Direct Memory Access,DMA)芯片,它可以控制在内存和某些控制器之间的位流,而无需CPU的干预.CPU对DMA芯片进行设置,说明要传送的字节数,有关的设备和内存地址以及操作方向.当DMA芯片完成时,它引发一个中断(-->进入第二种处理方式)

中断经常会在不合适的时刻发生,互相竞争时高优先级的中断赢得竞争.

#### 总线

![总线](./src/现代操作系统/总线1.png)

#### 启动计算机

基本输入输出系统(BIOS),保存在非可易失RAM中,操作系统可以对其进行更新.

1. BIOS检测RAM数量,键盘和其他基本设备是否安装并正常响应
2. 扫描ISA和PCI总线并找出连接在上面的所有设备,并把设备记录下来
3. 通过尝试存CMOS存储器中的设备清单决定启动设备(用户可以在启动时在BIOS中进行配置)
4. 系统从硬盘启动,**设备上的第一个扇区被读入内存并执行**,这个扇面中包含一个在启动扇面末尾的分区表检查程序,以确定哪一个分区时活动的
5. 从该分区读入第二个启动装载模块.来自活动分区的这个装载模块被读入操作系统,并启动之
6. 操作系统询问BIOS,以获得配置信息
7. 操作系统检查对应的设备驱动程序是否存在.如果存在就调入内核
8. 初始化有关参数,创建需要的任何背景进程,并在每个终端上启动登录程序或GUI

### 1.5操作系统概念

#### 进程

进程本质上时正在执行的一个程序.

*地址空间*从某个最小值到最大值的存储位置列表.在这个范围内,进程可以进行读写.其中包含可执行程序,程序的数据以及程序的堆栈.

还有资源集,打开的文件清单,突出的报警,有关进程清单,以运行该程序所需要的所有其他信息.

进程基本上是容纳运行一个程序所需要所有信息的容器

进程被挂起时,进程的所有信息都需要保存下来.

**操作系统中存放着一张表,进程表,他是数组结构,当前存在的每一个进程都要占用其中一项**


#### 地址空间

内存中可以只保留一个进程.

内存中存在多个程序时,需要借助于硬件来避免他们互相干扰.这种硬件由操作系统控制

#### 文件

绝对路径与相对路径

读写文件之前需要打开文件-->检查访问权限-->返回一个小整数(文件描述符)供后续操作使用,如果权限不足,则返回一个错误码

*mount系统调用*

UNIX中另一个重要的概念是特殊文件.为了使得I/O设备看起来像文件一般.这样就可以像使用系统调用读写文件一样.由两个特殊文件:*块特殊文件*和*字符特殊文件*.特殊文件在`/dev`下

管道是一种虚拟文件,他可以连接两个进程

### 1.6系统调用

**任何单CPU计算机一次只能执行一条指令**.如果一个进程在用户态中运行一个用户程序,并且需要一个系统服务,比如从一个文件读取数据,那么他就必须必须执行一个陷阱或者系统调用指令,将控制转移到操作系统.然后操作系统通过参数检查,找出所需要的调用进程.然后他执行系统调用,并把控制返回给在系统调用后面跟随着的指令.进行系统调用就像进行一个特殊的过程但是只有系统调用可以进入内核,而过程则不能.

read系统调用

![系统调用](./src/现代操作系统/系统调用.png)

1. 参数压入堆栈
4. 调用库过程
5. 把系统调用的编号放入寄存器中
6. 执行TRAP指令切换到内核态,并在内核中的一个固定地址开始执行
7. 查找系统调用编号(通过一张有系统调用编号所引用的,指向系统调用处理器的指针表来完成)
8. 系统调用句柄运行
9. 句柄完成工作,控制可能会在跟随TRAP指令后面的指令中返回给用户空间过程
10. 返回到用户程序
11. 为了完成整个工作,用户程序还必须清除堆栈,增加SP

上面*控制可能会在跟随TRAP指令后面的指令中返回给用户空间过程*:系统调用可能阻塞调用者,避免它继续执行.例如试图读键盘,但是并没有任何键入,那么调用者就必须被阻塞.在这种情形下,操作系统会查看是否有其他可以运行的进程.稍后,当需要的输入出现时,进行会提醒系统注意,然后9~11会接着运行.

POSIX大约有100个过程调用

进程管理
- pid=fork() 创建与父进程相同的子进程
- pid=waitpid(pid,@statloc,options) 等待一个子进程终止
- s=execve(name,argv,environp) 替换一个进程的核心映像
- exit(status) 终止进行执行并退出

文件管理
- fd=open(file,how,...) 打开一个文件供读,写或两者.
- s=close(fd) 关闭一个打开的文件
- n=read(fd,buffer,nbytes) 把数据从一个文件读到缓冲区中
- n=write(fd,buffer,nbytes) 把数据从缓冲区写到一个文件中
- position=lseek(fd,offset,whence) 移动文件指针
- s=stat(name,&buf) 取得文件的状态信息

目录和文件系统管理
- s=mkdir(name,mode) 创建一个新目录
- s=rmdir(name) 删除一个空目录
- s=link(name1,name2) 创建一个新目录项2,并指向name1
- s=unlink(name) 上去一个目录项
- s=mount(special,name,flag) 安装一个文件系统
- s=umount(special) 卸载一个文件系统

杂项
- s=chdir(dirname) 改变工作目录
- s=chmod(name,mode) 改变一个文件的保护位
- s=kill(pid,signal) 发送一个信号给一个进程
- seconds=time(&seconds) 自1970年一月一号起的流逝时间

#### 用于进程管理的系统调用

fork是唯一可以在posix创建进程的途径,他创建原有进程的精确副本.fork调用返回一个值,在子进程中该值为零,并且等于子进程的进程标识符,或等于父进程中的PID.使用被返回的PID,就可以分别出父子进程

```c
#include <stdio.h>;
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
void main(int argc, char **argv, char **envp)
{
    for(int i=0;i<argc;i++){
        printf("%s\n",argv[i]);
    }
    int pid = fork();
    if (pid == 0)
    {
        printf("%d", pid);
        printf("parent process");
    }
    else
    {
        printf("child process");
    }

    printf("\n");
}
```
main中argc表示命令行传递的参数个数,argv是参数数组,envp是环境

### 1.7 操作系统结构

单体系统,层次系统,微内核,客户-服务器,虚拟机等

## 第二章 进程与线程

### 2.1 进程

对于单处理器系统,某一瞬间只有一个进程在运行(伪并行)

#### 进程模型

多道程序设计实际是CPU在进程之间来回切换,在任何给定瞬间只有一个进程

#### 创建进程

4种情况下导致进程的创建:
- 系统初始化
- **执行了正在运行的进程所调用的进程创建系统调用**
- 用户请求创建一个新进程
- 一个批处理作业的初始化

停留在后台的进程称为*守护进程*,例如电子邮件,打印

fork之后子进程拥有与父进程相同的存储映像,同样的环境和同样的打开文件.**通常子进程接着执行execve或一个类似的系统调用,以修改其存储映像并运行一个新的程序**.

#### 进程终止

- 正常退出(自愿的)
- 出错退出(自愿的)
- 严重错误(非自愿)
- 被其他进程杀死(非自愿)

exit可以正常退出进程

严重错误:由进程引起的错误,在UNIX中进程可以通知操作系统,他希望自行处理某些类型的错误,在这类错误中,进程会受到信号(被中断),而不是在这类错误时出现终止

#### 进程的层次结构

unix中父子进程形成一棵树,windows中进程同级

#### 进程的状态

进程有自己的程序计数器和内部状态

运行-->就绪-->阻塞

**当多个程序就绪时,调度程序会决定运行那一个就绪进程,运行多长时间,什么时候运行**

调度程序是操作系统的最底层,在他上面有许多进程.所有关于中断处理,启动进程,停止进程的具体细节都隐藏在调度程序之中.调度程序是一段非常小的程序

#### 进程的实现

操作系统维护一张*进程表(process table)*,数组结构,每一个进程占据一项.每一项包含进程状态的重要信息,包括程序计数器,堆栈指针,内存分配状况,所打开的文件的状态,账号和*调度信息*.

![进程信息](./src/现代操作系统/进程信息.png)

与每一I/O关联的是一个称为*中断向量(interrupt vector)*的位置(靠近内存底部的固定区域).*他包含中断服务程序的入口地址*.

例如磁盘中断时,用户进程3正在运行,则中断硬件将程序计数器,程序状态字,有时还有一个或多个寄存器压入堆栈.计算机随即跳转到中断向量所指示的地址.这些是由硬件完成的所有操作,然后软件,特别是中断服务例程就接管一切剩余的工作.

所有中断都是从保存寄存器开始,随后会中堆栈中删除由中断硬件机制存入堆栈的那部分信息,并将堆栈指针指向一个由进程处理程序所使用的临时堆栈

服务例程结束后,他调用一个C过程处理某个特定的中断类型剩下的工作.在完成有关工作之后,大概就会有某些进程就绪,接着调度程序,决定运行哪个进程.然后由一段汇编代码将该进程装入寄存器并启动.

#### 多道程序设计模型

内存有n个进程时,所有n个进程都在等待I/O操作(此时CPU空转)的概率为P<sup>n</sup>

CPU利用率=1-P<sup>n</sup>

P=I/O时间 / 总时间

增加进程可以提高利用率,但是增加进程占用内存,需要扩大内存,但是随着进程数目的变多,内存扩大CPU利用率的提高会放慢

### 2.2 线程

应用程序中同时发生着多种活动,某些活动随着时间的推移会被阻塞.应用程序分解成可以准并行运行的多个顺序线程.

并行实体共享一个地址空间和所有可用数据的能力.这是多进程模型无法表达的

线程创建比进程创建要快10~100倍

cpu密集型,多线程没有意义.只有存在大量I/O时多线程才有意义

**在多CPU系统中,多线程,是的真正的并行具有实现的可能**

例子:Web服务器上运行一个*分派线程(dispatcher)*从网络中读入工作请求.检查请求之后,分派线程选择一个空转的(被阻塞的)*工作线程(worker thread)*处理请求.工作线程检查请求是否在高速缓存中...

*多线程*和*单线程*Web服务器

单线程服务器:可以使用read系统调用的非阻塞版本

**服务器在表格中记录当前请求的状态,然后去处理下一个事件.下一个事件可能是新的请求,或者磁盘对先前操作的回答.如果是磁盘的回答,就从表格中找出对应的信息,并处理该回答.对于非阻塞I/O,这种回答多数会议信号或中断的形式出现**

每次服务器从某个请求工作的状态切换到另一个状态时,都必须显示地保存或重新装入相应的计算状态.每一个计算都有一个被保存的状态,存在一个会发生且使得相关装填发生改变的事件集合,这种设计成为*有限状态机*

- 多线程:并行性,阻塞系统调用
- 单线程:无并行,阻塞系统调用
- 有限状态机:并行性,非阻塞系统调用,中断

#### 经典线程模型

进程模型给予两种独立的概念:资源分组和执行

进程把资源集中在一起,线程则是在CPU上被调度执行的实体

线程有一个程序计数器,用来记录接着要执行那一条指令.还有保存当前工作变量的寄存器.还有堆栈用来记录执行历史.

线程给进程增加了一向内容:同一个环境中,允许彼此之间有较大独立性的多个线程执行.

线程也叫*轻量级进程*

有些CPU直接硬件支持多线程,并允许线程切换在纳秒级完成

![线程结构](./src/现代操作系统/线程结构.png)

线程状态:阻塞,运行,就绪,终止

线程可以被阻塞,以便等待某个外部事件的发生或等待其他线程来释放他

- *thread_create* 可以创建一个线程
- *thread_exit*退出线程.
- *thread_join*可以等待某个线程的退出,他会阻塞当前线程,直到指定的线程退出为止
- *thread_yield*可以让当前线程主动让出CPU从而让另一个线程执行

#### POSIX线程

- *Pthread_create* 创建一个新线程
- *Pthread_exit* 结束调用的线程
- *Pthread_join* 等待一个特定的线程退出
- *Pthread_yield* 释放CPU来运行另外一个线程
- *Pthread_attr_init* 创建并初始化一个线程的属性结构
- *Pthread_attr_destroy* 删除一个线程的属性结构

*Pthread_create*,新创建的线程的线程标识符作为函数返回值,类似于fork,线程标识符起着PID的作用

*Pthread_attr_init*建立关联一个线程的属性结构并初始化成默认值,这些值(例如优先级)可以通过修改属性结构中的域值来改变

*Pthread_attr_destroy*删除一个线程的属性结构,释放他占用的内存.他不会影响调用他的线程,这些线程会持续存在

#### 在用户空间中实现线程

线程包两种实现方式:*用户空间*和*内核空间*,各有利弊.也有混合实现方式

内核对线程一无所知

第一个也是最明显的优点:可以在不支持线程的操作系统上实现

每个进程需要有专用的*线程表*,记录各个线程的属性

比陷入内核要快一个数量级

允许每个进程有自己定制的调度算法

**缺点**:

使用线程的主要目标:允许每个线程使用阻塞调用,还要避免被阻塞的线程影响其他的线程.有了阻塞系统调用,这个目标不是轻易地能够实现的.

一种可能的方案:如果某个调用会阻塞,就提前通知.UNIX中select可以允许调用者通知语气的read是否会阻塞.首先执行select调用,然后只有在不会阻塞的情况下才会执行read调用.如果会read调用会被阻塞,相关的调用就不进行,而是运行另一个线程

如果一个线程开始,进程中的其他线程就不能运行,除非第一个线程自动放弃CPU.在单独的进程内部,没有时钟中断,所以不可以用轮转调度方式调度.

只有在经常发生线程阻塞的应用中才希望使用多个线程

#### 内核中实现线程

内核线程速度慢

在内核中有用来记录系统中所有线程的线程表

当一个线程阻塞时,内核根据其选择,可以运行统一进程中的另一个线程,或者另一个进程中的线程.(用户级线程,只能运行自己进程中的线程)

在内核中创建和撤销线程的代价大.(有些系统回收线程,当线程撤销时,把他标志为不可运行)

内核线程不需要任何新的,非阻塞系统调用.另外如果某个进程中的线程引起了页面故障,内核可以很方便的检查进程是否有任何其他可运行的线程

> 创建子进程时,子进程是否拥有与父进程一样的线程,还是只有一个线程.很多情况下取决于下一步要做什么.如果子进程继续执行,那么复制所有,如果调用exec启动一个新的程序,那么一个线程可能比较合适


> 信号是发送个进程而不是线程的.当信号到来时,应该由哪一个线程处理它.如果线程可以注册他们感兴趣的信号,那么多个线程注册同一个信号会发生什么

#### 混合实现

用户线程与部分或全部内核线程多路复用

编程人员可以拥有多少个内核线程和多少个用户级线程多路复用

每个内核线程有一个可以轮流使用的用户级线程集合

#### 调度程序激活机制

目标是模拟内核线程的功能,但是为线程包提供通常在用户空间才能实现的更好的性能和更大的灵活性.特别的,如果用户线程从事的某种系统调用时安全的,那就不应该进行专门的非阻塞调用或者进行提前检查.无论如何,如果线程阻塞在某个系统调用或者页面故障上,只要一个进程中有任何就绪的线程,就应该可能运行其他的线程

内核给每个进程安排一定数量的*虚拟处理器*,并且让(用户空间)运行时系统将线程分配到处理器上.在多处理器系统中,虚拟处理器有可能成为正式的处理器.分配给进程的虚拟处理器的初始数量只有一个,但是进程可以申请跟多的处理器,并且在不用时退回.内核也可以取回已经分配出去的虚拟处理器,以便把他们分配给其他进程

基本思路:当内核了解到一个线程被阻塞之后,内核通知该进程的运行时系统,并且在堆栈中以参数形式传递有问题的线程编号和所发生事件的一个描述.内核通过在一个已知的起始地址启动**运行时系统**,**从而发出了通知**.这是对**UNIX信号的一种粗略模拟**.这个机制称为**上行调用**

一旦如此激活,**运行系统就重新调度器线程**.过程通常如下:把当前线程标记为阻塞并从就绪表中取出另一个线程,设置其寄存器,然后再启动之.**当内核知道原来的线程有可运行时**,内核就**又一次** **上行调用**运行时系统,通知他这一事件.此时,运进行时系统按照自己的判断,或者立即重启被阻塞的线程.或者把他放入就绪表中.

如果**某个用户线程运行的同事发生一个硬件中断时**,**被中断的CPU切换进核心态**.如果**被中断的进程对引起该中断的事件不感兴趣**,那么**中断处理程序结束之后**,就把**被中断的线程回复到中断之前的状态**.如果**感兴趣**,那么此时**被中断的线程就不在启动,挂起该线程**.**运行时系统启动对应的虚拟CPU**,此时**被中断线程保存在堆栈中**.**随后运行时系统决定在该CPU上调度哪一个线程**.

#### 弹出式线程

在分布式系统中经常使用线程.例如处理消息的到来.

传统方式是将进程或线程阻塞在一个receive系统调用了.

另一种,创建一个处理消息的线程,这种线程称为弹出式线程

内核空间运行弹出线程比用户空间容易快捷,并且可以访问所有的表格和I/O设备,处理中断时非常有用.

出错的内核线程比用户线程造成的损害更大

#### 单线程多线程化


### 2.3 进程间通信IPC(Inter Process Communication)

#### 竞争条件

两个或多个进程读写某些共享数据,而最后的结果取决于进程运行的精确时序,称为*竞争条件*

#### 临界区

找出某种途径来组织多个进程同时读写共享的数据,也就是他们需要*互斥(mutual exclusion)*.

对共享内存进行访问的程序片段称为*临界区(critical section)*

好的解决方案的4个条件:
- 任何两个进程不能同时处于临界区
- 不应对CPU的速度和数量做任何的假设
- 临界区外运行的进程不得阻塞其他进程
- 不得使进程无限期等待进去临界区

#### 忙等待的互斥

##### 屏蔽中断(不可行)

在进程进入临界区时屏蔽所有中断,离开之前在打开中断.屏蔽中断后,时钟中断也被屏蔽.CPU不会切换到其他进程.

只能屏蔽当前CPU中断,不能屏蔽其他CPU中断.并且临界区可能不会退出来

##### 锁变量(不可行)

设想一个共享锁变量,初始值为0.当一个进程想进入临界区时,先测试这把锁,如果值为0,则把值设置为1,并进入临界区.

如果读取到值为0的时候,在他设置为1之前另一个进程被切换过来运行,此时也读取到0,那么他们都认为自己可以进入临界区.

##### 严格轮换法

使用turn来记录轮到哪一个进程进入临界区,初始值为0
```c
//进程0
while 1{
    while(turn!=0)
    critical_region();
    turn=1;
    noncritical_region();
}
```
```c
//进程1
while 1{
    while(turn!=1)
    critical_region();
    turn=0;
    noncritical_region();
}
```
进程0发现turn为0,进入临界区.进程1发现turn不是1,所以进入*忙等待*(连续测试一个变量知道某个值出现为止).只有有理由认为等待时间非常短的情况下,才使用忙等待.用于忙等待的锁称为*自旋锁*.

进程0退出临界区时,在turn值设置为1.此时turn的值1,两个进程都在临界区外执行.

突然进程0结束了非临界区的操作并进入循环的开始.但是这时他不能进入临街区.因为turn的当前值为1,而此时进程1还在忙于非临界区的操作,进程0只有继续while循环,直到进程1把turn值改为0

进程0被非临界区之外的进程阻塞了.

*这个方案要求两个进程严格地轮流进入他们的临界区*

##### Peterson解法

不需要严格轮换的软件互斥算法

```c
#define False 0
#define True 1
#define N 2 //进程数量

int turn; //现在轮到谁?
int interested[N];//所有值初始化为0(False)

void enter_region(int process){
    int other; //其他进程号
    other=1-process;//另一个进程
    interested[process]=True;//表明感兴趣的
    turn=process;//设置标志
    while(turn==process && interested[other]==True);//空语句
}
void leave_region(int process){//进程:谁离开
    interested[process]=Fasle;//表示离开临界区
}
```
开始时没有任何进程进入临界区.现在进程0调用`enter_region`.它通过设置其数组元素和将turn设置为0来标识它希望进入临界区,由于进程1并不想进入临界区.所以`enter_region`很快就返回.

假设两个进程几乎同时调用`enter_region`他们都将自己的进程号存入turn,加入进程1后存入,则turn为1,那么进程0将循环0次并进入临界区.二进程1将不停的循环,直到进程0退出临界区

一直忙等待

##### TSL指令

`TSL RX,LOCK`

TSL时*测试并加锁*,它将一个内存字lock读取到寄存RX中.然后**在改内存地址上存一个非0值**.**读和写时不可分割的**.**该指令结束之前其他处理器不允许访问该内存字**.**执行TSL的CPU会锁住内存中线**,**以禁止其他CPU在本指令结束之前访问内存**

当lock为0时任何进程都可以使用TSL将其设置为1,并读写共享内存.当操作结束时,进程用一条普通的move指令将lock值设置为0

```
enter_region:
    TSL REGISTER ,LOCK | 复制锁到寄存器并将锁设置为1
    CMP REGISTER,#0    | 锁时0吗?
    JNE enter_region   | 若不是0,说明锁已经被设置,所以循环
    RET                | 返回调用者,进入临界区
leave_region:
    MOVE LOCK,#0       | 将锁存入0
    RET                | 返回调用者
```


##### 睡眠与唤醒

TSL和Peterson的解法都是忙等待.他们浪费CPU,他们的原理就是:**先检查是否可以进入临界区,若不可以就一直等待,直到允许为止**

当两个进程具有优先级时,如果高优先级的进程等待低优先级的进程释放锁,但是**低优先级的进程始终没有机会释放锁**,那么**高优先级进程会一直等待**.这种情况叫做**优先级反转问题**

考察进程间通信原语.**他们在无法进入临界区时将被阻塞,而不是忙等待**.最简单的是**sleep**和**wakeup**.sleep事一个将引起进程阻塞的系统调用,即被挂起.**直到另一个进程将其唤醒**.**wakeup调用一个参数,即将要被唤醒的进程**.另一个方法是sleep和wakeup都有一个参数

**消费者和生产者问题**也叫有界缓冲区.两个进程共享一个固定大小的缓冲区

生产者写入缓冲区,如果缓冲区满,则挂起.消费者取出消息,如果缓存空,消费者就挂起

设缓冲区有N个数据项,count记录已有数据项.生产者检查count.如果count不满,则写入数据,并且增量count,然后唤醒消费者.消费者检查count如果count=0就挂起,否则取出数据,递减count,然后唤醒生产者

```cpp
#define N 100 //缓冲区槽数目
int count=0; //缓冲区数据数目

void producer(void){
    int item;
    while(True){// 无限循环
        item=produce_item(); // 产生下一个数据项
        if(count==N) sleep(); // 如果缓冲区满了就睡眠
        insert_item(item);   // 将新的数据项放入缓冲区
        count=count+1;       // 缓冲区数据项数目增1
        if(count==1) wakeup(consumer);// 缓冲区空吗
    }
}

void consumer(void){
    int item;
    while (True){
        if(count==0) sleep;  //如果缓冲区空就睡眠
        item=remove_item();  // 从缓冲区取出一个数据项
        count=count-1;       // 缓冲区数据项数目减1
        if(count=N-1) wakeup(producer);// 缓冲区满吗
        consume_item(item); //打印数据项
    }
}
```
回到竞争条件,这里的count的访问没有加以限制.如果消费者读出count的值为0,于是他决定睡眠,但是在他睡眠之前,生产者进程开始运行,生产者判定count==1,于是他wakeup消费者,但是这里的消费者却还未睡眠.
于是wakeup信号丢失了.

一个快速弥补方法,加上一个唤醒等待位.当一个wakeup信号发送给一个清醒的进程信号时**,将改位置1.随后当该进程要睡眠时,如果唤醒等待位为1**,那么清楚该位,而该进程任然保持清醒.**但是当进程数量庞大时,就要添加无数个唤醒等待位**,*没有从根本上解决问题*

##### 信号量

使用一个**整型变量来累计唤醒次数**,供以后使用. 引入了一个新型变量类型,称作*信号量*.信号量的取值可以是0(表示没有保存下来的唤醒操作)或者正值(表示有一个或多个唤醒操作)

对信号量的down操作:检查其值是否大于0,大于0,则减1,并继续,若该值为0,则进程睡眠,而且此时down操作并未结束.检查数值,修改变量值以及可能发生的睡眠是一个单一的不可分割的原子操作.保证该操作完成或阻塞之前,其他进程均无法访问该信号量

up操作,对信号量加1,如果一个或多个进程在该信号量上睡眠,无法完成先前的down操做,则有系统选择其中一个并允许该进程完成它的down操作.于是,对于一个有进程在其上睡眠的信号量执行一次up操作之后,该信号量值仍为0,但是其上的睡眠的进程却少了一个.信号量的增1和唤醒一个进程也是不可分割的

**用信号量解决生产者和消费者问题**

通产up和down作为系统调用实现.而且只需在执行以下操作时暂时屏蔽全部中断:测试信号量,更新信号量以及在需要时使某个进程睡眠.**如果是多个CPU,则每个信号量应由一个锁变量进行保护.通过TSL或XCHG**

使用3个信号量,full表示缓冲区槽数目,一个empty记录空的缓冲槽总数,一个mutex用来确保生产者和消费者不会同时访问缓冲区,mutex初值为1.

供两个或多个进程使用的信号量,其初值为1,保证同时只有一个进程可以进入临界区,称作*二元信号量*.**如果每个进程在进入临界区前都执行一个down操作,并在刚刚推出时执行一个up操作,就能实现互斥**

使用信号量的系统中,隐藏中断最自然的方法是为每一个I/O设备设置一个信号量,其初值为0.当启动一个I/OS设备之后,管理进程就立即对相关量的信号量执行一个down操作,于是进程立即被阻塞.当中断到来时,中断处理程序随后对相关信号量执行一个up操作,从而将相关的进程设为就绪状态

```c
#define N 100 //缓冲区槽数目
typedef int semaphore //信号量是一种特殊的整型数据
semahpore mutex=1; //控制临界区的访问
semaphore empty=N; //计数空槽数
semaphore full=0; //计数非空槽数


void producer(void){
    int item;
    while(True){// 无限循环
        item=produce_item(); // 产生下一个数据项
        down(&empty); //空槽数减1
        down(&mutex); //进入临界区
        insert_item(item);   // 将新的数据项放入缓冲区
        up(&mutex);      // 离开缓冲区
        up(&full);   // 非空槽数加1
    }
}

void consumer(void){
    int item;
    while (True){
        down(&full); //空非槽数减1
        down(&mutex); //进入临界区
        item=remove_item();  // 从缓冲区取出一个数据项
        up(&mutex);      // 离开缓冲区
        up(&full);   // 非空槽数加1
        consume_item(item); //打印数据项
    }
}
```
信号量的另一种用途是实现同步(synchronization),信号量full和empty用来保证某种事件的顺序发生或不发生.上面例子:保证缓冲区满的时候生产者停止运行,以及缓冲区空时消费者停止运行

**就是说一旦down的参数值变为0则该进程阻塞所以如果empty大于0,生产者是不会睡眠的,而mutex是为了保护缓冲队列同时只能被一个进程操作**

##### 互斥量

**如果不需要信号量的计数能力**.可以使用简化版*互斥量(mutex)* 互斥量实现简单,**在用户空间线程包非常有用**

互斥量是可以处于**两态之一**的变量:**加锁和解锁**.**只需要一个二进制位**.当一个线程需要进入临界区时,他要调用`mutex_lock`,如果调用`mutex_lock`时互斥量已经枷锁,则调用线程被阻塞.直到临界区线程`mutex_unlock`

如果有可用的TSL和XCHG,可以很容易地用户空间实现他们

```
mutex_lock:
    TSL REGISTER,MUTEX |将互斥量复制到寄存器,并且将互斥量置为1
    CMP REGISTER,#0    |互斥量是0吗
    JZE OK             |如果互斥量为0,他被解锁,所以返回
    CALL thread_yield  |互斥量忙,调度另一个线程
    JMP mutex_lock     | 稍后再试
ok:RET                 |返回调用者,进入临界区

mutex_unlock:
    MOVE MUTEX,#0     |将mutex置为0
    RET               |返回调用者
```

上面如果测试失败该线程就主动让出CPU,

由于thread_yield只是在用户空间中对线程调度程序的一个调用,不会进入内核,所以执行非常快.用户线程完成可以实现在用户空间中的同步,这些过程只需要少量的指令.

有时线程包提供一个调用mutex_trylock,要么获得锁,要么返回失败码,但不阻塞线程.这就给调用线程一个灵活性,是使用替代办法还是只是等待下去.
(例如,mutex_trylock失败,可以yield也可以执行其他方法)

**多个`进程`如何共享信号量,或公共缓冲区,他们如何共享turn变量呢?(线程在统一进程空间内不用考虑)**

两种方案:共享数据结构,如信号量,放在内核当中,并且只能通过系统调用访问;多数现代操作系统(UNIX和Windows)提供一种方法,让进程和其他进程共享部分地址空间,这种方法中,缓冲区和其他数据结构可以共存,在最坏的情况下,如果没有共享的途径,则可以使用共享问阿金

**Pthread中互斥**

Pthread提供许多可以用来同步线程的函数.他使用一个可以被解锁和枷锁的互斥量来保护每个临界区.如果互斥量已经被加锁,则调用线程被阻塞,直到该互斥量被解锁.当他被解锁时,等待的线程中只有一个允许被运行并将互斥量重新锁定

还有一个系统调用可以尝试锁住一个互斥量,当互斥量被已加锁时会返回错误,而不是阻塞调用者`pthread_mutex_trylock`

- `pthread_mutex_init` 创建互斥量
- `pthread_mutex_destroy` 撤销一个已存在的互斥量
- `pthread_mutex_lock` 获得一个锁或者阻塞
- `pthread_mutex_trylock` 获得一个锁或失败
- `pthread_mutex_unlock` 释放一个锁

除了互斥量还有`条件变量`

`pthread_cond_wait`和`pthread_cond_signal`,wait阻塞调用线程直到另一个线程向他发送信号.
- `pthread_cond_init` 创建一个条件变量
- `pthread_cond_destroy` 撤销一个条件变量
- `pthread_cond_wait` 阻塞以等待一个信号
- `pthread_cond_signal` 向一个线程发送信号来唤醒他
- `pthread_cond_broadcast` 向多个线程发送信号来让她们全部唤醒

被阻塞的线程通常是去做某些工作,释放某些资源或是进行其他的一些活动,只有完成阻塞的线程才可以继续运行.

条件变量和互斥量经常一起使用.这种模式让一个线程锁住一个互斥量,然后当它补鞥呢获得它期待的结果时,等待一个条件变量.最后另一个线程会向他发送信号,使它继续执行.由于这个原因,互斥量是参数之一.

**条件变量(不想信号量)不会存在内存中,如果将一个信号量传递给一个没有线程在等待的条件变量,那么信号量就会丢失,必须小心使用避免丢失信号**

```c
#include <stdio.h>
#include <pthread.h>
#define MAX 100000000 /*需要生产的数量*/
pthread_mutex_t the_mutex;
pthread_cond_t condc, condp;
int buffer = 0; /*缓冲区*/

void *producer(void *ptr)
{
    int i;
    for (i = 1; i < MAX; i++)
    {
        pthread_mutex_lock(&the_mutex); //互斥使用缓冲区
        while (buffer != 0)
            pthread_cond_wait(&condp, &the_mutex);
        buffer = i;
        ptread_cond_signal(&condc);
        pthread_mutex_unlock(&the_mutex);
    }
    pthread_exit(0);
}

void *consumer(void *ptr)
{
    int i;
    for (i = 1; i < MAX; i++)
    {
        pthread_mutex_lock(&the_mutex); //互斥使用缓冲区
        while (buffer == 0)
            pthread_cond_wait(&condc, &the_mutex);
        buffer = 0;
        ptread_cond_signal(&condp);
        pthread_mutex_unlock(&the_mutex);
    }
    pthread_exit(0);
}

int main(int argc, char **argv)
{
    // 创建条件变量和互斥量
    pthread_t pro, con;
    pthread_mutex_init(&the_mutex, 0);
    pthread_cond_init(&condc, 0);
    pthread_cond_init(&condp, 0);
    // 创建线程
    phread_create(&con, 0, consumer, 0);
    phread_create(&pro, 0, producer, 0);
    // 等待线程结束
    pthread_join(pro, 0);
    pthread_join(con, 0);
    // 删除条件变量和互斥量
    pthread_cond_destroy(&condc);
    pthread_cond_destroy(&condp);
    pthread_mutex_destroy(&the_mutex);
}
```

##### 管程

一种高级的同于原语*管程*,管程由一个过程,变量,数据结构等组成的一个集合,他们组成特殊的模块或包,进程可以在任何需要的时候调用管程中的过程,但他们不能再管程之外声明过程中直接访问的管程内的数据结构,**任意时刻管程中只有一个活跃的进程**.编程时只需要把临界区转换成管程即可,绝不会有两个进程同时执行临界区的代码.

但是消费者或者生产者如何阻塞呢?使用条件变量,如果缓冲区满,那么调用wait使得改进程自身阻塞.

**管程和信号量的机制都是用来解决访问公共内存的一个或多个CPU上的互斥问题.如果是分布式CPU,每个CPU有自己的内存,他们通过一个局域网相连,那么这些原语将失效;这里的结论是:信号量态低级,而管程在少数几种编程语言之外又无法使用,并且他们未提供信息交换方法**

##### 消息传递

send和receive是系统调用而不是语言组成部分,他们像信号量而不像管程.

`send(destination,&message)`和`receive(source,&message)`

如果没有消息,那么接受者可能阻塞,直到一条消息到达,后者带着一个错误码立即返回

##### 消息传递设计要点

对于网络中的不同机器上的通信进程,消息有可能被网络丢失,为了防止消息丢失,发送方和接收方制定协议一但接收到消息,接受方马上回送一条特殊的确认消息,如果发送方在一段时间内没有接受到确认,则重发消息

如何区分一条消息是否是重发的可以在媒体哦啊原始消息嵌入一个连续的序号来解决问题

##### 用消息传递解决

生产者产生消息,满时阻塞,等待消费者,空时消费者阻塞,等待生产者

使用能够容纳N条消息的信箱,生产者向消费者信箱发送包含数据的消息,消费者向生产者信箱发送空的消息.当使用信箱时,缓冲机制的作用是很清楚的:目标信箱容纳那些已被发送但尚未被目标进程接受的消息

##### 屏障

所有线程到达同一个地方停下来

### 2.4 调度

当有多个进程处于就绪状态时,如何选择下一个要运行的进程,由调度程序来完成,该程序使用的算法是调度算法

为了选取正确的进程运行,调度程序需要考虑CPU利用率,因为进程切换代价比较高,需要切换到内核态,还要保存当前进程的状态,并且在进程表中存储寄存器值以便重新装载,并且高速缓存也会失效,总之,**如果每秒切换进程的次数太多,会消耗大量CPU时间**

##### 进程行为

几乎所有的进程的I/O请求或计算都是交替突发的.CPU不停顿的运行一段时间,然后发出一个系统调用以便读写文件.在完成系统调用过之后CPU又开始计算.**某些I/O可以看做是计算,例如CPU向RAM复制数据以更新屏幕,因为使用了CPU所以是计算**

有些进程花费大量时间在计算上**CPU密集型**,有些花费在I/O上**I/O密集型**

随着CPU变得越来越快,更多的进程倾向于I/O密集型,**应该让I/O密集型进程尽快得到运行机会,以便发出磁盘请求并保持磁盘始终忙碌**

##### 何时调度

- 创建新进程时应该运行父进程还是子进程
- 一个进程退出时
- 一个进程被阻塞时
- 发生I/O中断时

根据始终中断可以把调度分为两类:**非抢占式调度算法**(等待进程被阻塞或者运行结束),**抢占式调度**(让进程运行固定的时间,如果进程未结束就挂起,而调度程序选择其他进程运行)

##### 调度算法分类

按照系统来分:
- 批处理:一般非抢占式调度
- 交互式:抢占式调度
- 实时:抢占式

##### 调度算法目标

运行大量批处理作业的机器.通常检查三个指标:吞吐量,周转时间以及CPU利用率;

**吞吐量**是每小时完成作业数量,**周转时间**是作业从提交到结束的平均时间,越小越好;

吞吐量大周转时间不一定小

CPU利用率并不是一个好的度量参数

对于交互式系统,最重要的是最小响应时间

实时系统,满足所有的截止时间要求

#### 批处理系统的调度

- 先来先服务
- 最短作业优先
- 最短剩余时间优先


#### 交互系统的调度

##### 轮转调度

每个进程分配一个时间段(**时间片**),时间到,没有结束就强行停止,运行其他进程

**时间片的长度**

例如:进程切换需要1ms,时间片是4ms,那么20%时间浪费在管理开销上;那么加入时间片100ms,那么浪费1%管理时间,但是如果有50个进程请求,那么最后一个进程必须等到5秒后才能运行;

**时间片一般在20~50ms,太短导致过多进程切换,太长导致交互请求时间太长**

##### 优先级调度

每个进程赋予一个优先级,优先级高的可运行进程先运行

每个进程富裕一个运行的最大时间片,当时间片用完时,选择下一个次高优先级的进程运行

**优先级可以静态赋予或动态赋予**

当某个进程为I/O密集型,那么当该进程需要CPU时应该立即分配给他CPU,一遍启动下一个I/O请求,这样可以在另一个进程计算的同事执行I/O操作.**使I/O密集型获得较好服务的一种简单算法是,将其优先级设为1/f,f为该进程在上一时间片中所占的部分.一个在其50ms时间片中只是用1ms的进程将获得优先级50,而阻塞之前用掉25ms的进程拥有优先级2(这里数值越大优先级越高)**

**如果不对优先级进行调整,则低优先级的进程可能会差生饥饿现象**

##### 多级队列

对于CPU密集型进程设置较长的时间片比频繁地分给他们很短的时间片更为高效(减少交换次数)属于最高优先级的进程运行一个时间片,属于次高优先级的进程运行2个时间片,再4个时间片...,当进程用完时间片时,就移到下一个类

随着及承诺很的优先级不断降低,他的运行频度不断放慢,**从而为短的交互进程让出CPU**

##### 最短进程优先

如何从当前进程中找出最短的进程

**根据过去的行为推测**

##### 保证调度

每个进程得到cpu处理能力的1/n.必须跟踪每个进程从创建以来使用的多少CPU时间.然后它计算进程应该获得的CPU时间,即自创建以来的时间除以n.由于各个进程实际获得CPU时间是已知的所以可以很容易计算出真正获得的CPU时间和应获得CPU时间比.例如:比率0.5说明一个进程,只获得应得时间的一般,,而比率2.0,则说民它获得了应得时间的2倍,于是改算法随后转向比率最低的进程,知道该进程的比率超过最接近竞争者为止

##### 彩票调度

彩票交换,彩票数量与赢得鼓励机会正比,每秒钟50次,每次奖励20msCPU

#### 实时系统的调度

软实时和硬实时

实时系统的事件分为:周期性和非周期性事件

例子:有3个周期性事件的软实系统,周期分别是100ms,200ms,500ms,分别需要50ms,30ms,100msCPU时间,那么系统是可调度的,因为0.5+0.15+0.2&lt;1
假若第4个事件周期1秒,cpu事件150ms,那么还是可调度的,这里假设山下问切换开销很小

#### 策略和机制

场景:数据进程有多个子进程,每个子进程实现不同功能,主进程可以掌握哪一个子进程最重要

**将调度机制和调度策略分离**,**也就是将调度算法参数化,参数可以由用户进程填写**

**调度机制位于内核,二调度策略由用户进程决定**

#### 线程调度

用户级线程和内核级线程之间的差别在于性能.用户级线程切换需要少量的机器指令,而内核级线程需要完整的上下文且含,修改内存映像,是高速缓存失败,者导致若干数量级的延迟.另一方面,使用内核级线程时,一旦线程阻塞在I/O上就不要将整个进程挂起

用户级线程可以使用专门为应用程序定制的线程调度程序,一般而言定制的线程调度程序能够比内核更好的满足应用的需要

### 经典的IPC问题

#### 哲学家就餐
....
#### 读者-写者问题
....


# 内存管理


## 存储抽象:地址空间

### 概念
多个应用程序互不影响,需要解决两个问题:保护和重定位.

**地址空间**是一个进程可用于寻址内存的一套地址集合

每个进程都有一个自己的地址空间,并且地址空间独立于其他进程的地址空间(除非他们有共享的地址空间)

#### 如何实现地址空间的隔离

**基址寄存器与界限寄存器**

它简单的把每个进程的地址空间映射到物理内存的不同部分

当程序运行时,把起始物理地址装载到基址寄存器,程序的长度装载到界限寄存器

每次程序访问内存时,CPU硬件自动把请求地址加上基地址,如果实际地址超出界限寄存器存储的值,就产生错误并终止访问

例如:`jmp 28`基地址为10000,那么实际为10028,如果界限寄存器值小于10028就产生错误

#### 交换技术

当有很多进程时,一部分进程在内存中,一部分不在.当运行进程时就把它装载进内存.这就是交换的简单概念.

进程在磁盘与内存调入调出时,使得进程的基地址发生改变,那么需要重定位.并且调入调出使得内存产生多个空闲区(hole也叫空洞),通过把进程尽可能向下移动来将小的空闲区合成一大块,**内存紧缩**,但是这么做要耗费大量时间

**进程需要的内存大小又是不固定的,运行期间可能申请更多的内存,那么如果相邻内存区域已经存在其他进程怎么办**

把它移动到足够大的内存区域中,或者调出到磁盘,如果磁盘也满了,那么久挂起,这显然会有很多问题产生

当进程初始化时为进城多分配一些空间(如果进程不增长那么就浪费了,如果增长不够,还是要移动到足够大的内存区域中)

#### 空闲内存管理

##### 使用位图存储管理

内存可能被化分层几个字或者几千字的分配单元,每个分配单元对应于位图中的一位,0表示空闲,1表示占用,

![位图内存管理](./src/现代操作系统/内存1.png)

分配单元越小位图越大,单元越大,位图越小,但是若进程需要的内存单元的最后一个占用的内存很小的话,就会浪费更多的内存

**查找内存中连续个0的内存单元是耗时的操作,这是位图的缺点**

##### 使用链表存储管理

链表的一个节点要么是空闲去,要么包含一个进程.节点包含以下信息:空闲区(H)或进程(P)的标志位,其实地址,指向下一个节点的指针

进程结束时,它所在的节点变成H,如果他的邻居也是H,那么要和邻居合并.

分配内存方式:

- 首次匹配法:第一次遇到可用大小时就分配给进程.然后将进程不需要的内存,变成H(还有下次适配法,但是不如首次性能高)
- 最佳适配法:找出能够容纳进程的最小空闲区,而不是去把大的空闲区拆分(**但是他比首次和下次适配浪费内存更大,因为他使得内存大量无用的小空闲区**)
- 最差适配法:总是使用最大的可用空闲区(**但是也不好**)

**他们都增加了复杂度,并且内存释放速度变慢,因为必须将一个回收的段从进程链表中删除并插入空闲区链表**

**进程和空闲区使用不同的链表,并且空闲区按大小排序,那么最佳适配法可以加快**

## 虚拟内存

程序所需要的内存远大于物理内存.

**虚拟内存管理**:每个程序拥有自己的地址空间,这个空间被分割成多个块,每个块称作一页或页面.每一页有连续的地址范围.这些页被映射到物理内存,但并不是所有的页都在内存中才能运行程序.当程序引用的一部分在物理内存的地址空间中时,由硬件执行必要的映射,当程序引用到一部分不在物理内存时,由操作系统负责将缺失的部分装入无力内存,并重新执行失败的指令

从某种角度来讲,虚拟内存是对基址寄存器和界限寄存器的一种综合

### 分页

`mov reg 1000`这里是将地址为1000的内存单元复制到reg中,地址可以通过搜因,基址寄存器,段寄存器或其他方式产生

由程序产生的地址成为**虚拟地址**,它构成了虚拟地址空间.在没有虚拟内存的计算机上,地址直接放到内存总线上.具有虚拟地址时,地址不是送到内存总线,而是送到**内存管理单元(Memory Management Unit MMU)**,MMU把虚拟地址映射为物理地址

![分页](./src/现代操作系统/内存2.png)

虚拟地址空间按固定大小划分成称为**页面(page)**的若干单元,在物理内存总对应的单元称为**页框(page frame)**,页面和页框大小通常一样,一般是512字节到64KB大小.RAM和磁盘总是以整个页面为交换单元

当操作内存是发现没有映射为物理内存是,CPU陷入到操作系统,这个陷阱称为**缺页中断(page fault)**.操作系统找到一个很少使用的页框把它的内容写入磁盘,随后把需要访问的页面督导刚才回收的页框中,修改映射关系,然后重新启动引起陷阱的指令

#### MMU内部结构

例如虚拟地址8196==0010000000000100,16位的虚拟地址分为4位页号和12位偏移量

页号可以当做页表(page table)的索引,以得出对应于该虚拟页面的页框号

#### 页表

虚拟页号可以做为页表的索引,虚拟地址被分成虚拟页号和偏移量.对于16位地址和4KB的页面大小,高4位可以指定16个虚拟页面中的一页,而低12位接着确定了所选页面中偏移量

页表的目的是把虚拟页面映射为页框,从数学角度说,页表是一个函数,参数是虚拟页号,结果是物理页框号

**页表项的结构**

页表项的结构是与机器密切相关的,但不同的机器的页表项存储的信息都大致相同.

- 页表项最重要的是页框号
- 其次是在/不在
- 保护位:可以是一位,表示只读,读写,或者3位表示:读,写,执行
- 修改位(脏位):表示页面是否被修改过,如果页面被修改过,那么必须写回磁盘,否则可以直接丢弃.
- 访问位:无论是读还是写,系统都会在该页面被访问时设置访问位,他的值用来帮助曹组哦系统在发生缺页中断时选择要被淘汰的页面,在页面置换算法中会起到重要作用
- 禁止页面被高速缓存位

####  加速分页过程

分页系统的两个问题:
- 虚拟地址映射到物理地址必须非常快
- 如果虚拟地址空间很大,页表也会很大




# 死锁