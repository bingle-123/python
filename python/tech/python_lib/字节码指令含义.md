# 字节码指令含义 3.6

## NOP

不要做任何代码。用作字节码优化器的占位符。

```c
#define FAST_DISPATCH() goto fast_next_opcode
TARGET(NOP)
            FAST_DISPATCH();

```

## LOAD_FAST

函数内部使用,将指定位置变量值压入栈顶

> 函数 参数-->局部变量-->freevar-->cells 按照位置顺序存放,oparg就是位置索引

```c
TARGET(LOAD_FAST) {
    PyObject *value = GETLOCAL(oparg);
    if (value == NULL) {
        format_exc_check_arg(PyExc_UnboundLocalError,
                                UNBOUNDLOCAL_ERROR_MSG,
                                PyTuple_GetItem(co->co_varnames, oparg));
        goto error;
    }
    Py_INCREF(value);
    PUSH(value);
    FAST_DISPATCH();
}
```

## LOAD_CONST

将code对象中的consts元组中指定oparg位置索引的值压入栈中

```c
TARGET(LOAD_CONST) {
    PyObject *value = GETITEM(consts, oparg);
    Py_INCREF(value);
    PUSH(value);
    FAST_DISPATCH();
}
```

## STORE_FAST

将栈顶元素移出,并放到local变量元组指定oparg索引位置

```c
TARGET(STORE_FAST) {
    PyObject *value = POP();
    SETLOCAL(oparg, value);
    FAST_DISPATCH();
}
```

## POP_TOP

移出栈顶元素

```c
TARGET(POP_TOP) {
    PyObject *value = POP();
    Py_DECREF(value);
    FAST_DISPATCH();
}
```

## ROT_TWO

交换栈最上面两个元素位置
```c
TARGET(ROT_TWO) {
    PyObject *top = TOP();
    PyObject *second = SECOND();
    SET_TOP(second);
    SET_SECOND(top);
    FAST_DISPATCH();
}
```

## ROT_THREE

栈顶三个元素位置调换 1,2,3--->2,3,1

```c
TARGET(ROT_THREE) {
    PyObject *top = TOP();
    PyObject *second = SECOND();
    PyObject *third = THIRD();
    SET_TOP(second);
    SET_SECOND(third);
    SET_THIRD(top);
    FAST_DISPATCH();
}
```

## DUP_TOP

复制当前栈顶元素,并将复制的栈顶元素压入栈中

```c
TARGET(DUP_TOP) {
    PyObject *top = TOP();
    Py_INCREF(top);
    PUSH(top);
    FAST_DISPATCH();
}
```

## DUP\_TOP\_TWO

复制栈顶的两个元素:获取当前栈顶的两个元素,然后在栈顶扩展2位置,把当前栈顶的两个元素按照原先位置压入占中,

```c
TARGET(DUP_TOP_TWO) {
    PyObject *top = TOP();
    PyObject *second = SECOND();
    Py_INCREF(top);
    Py_INCREF(second);
    STACKADJ(2);//将栈指针扩充两个位置,
    SET_TOP(top);
    SET_SECOND(second);
    FAST_DISPATCH();
}
```

## UNARY_POSITIVE (a=+a)

栈顶的元素调用该元素的`(o->ob_type->tp_as_number-->nb_positive)(o)`来获取其正数

```python
def test(a):
    a=+a
    a=-a
    a= not a
    a=~a

#   2           0 LOAD_FAST                0 (a)
#               2 UNARY_POSITIVE
#               4 STORE_FAST               0 (a)

#   3           6 LOAD_FAST                0 (a)
#               8 UNARY_NEGATIVE
#              10 STORE_FAST               0 (a)

#   4          12 LOAD_FAST                0 (a)
#              14 UNARY_NOT
#              16 STORE_FAST               0 (a)

#   5          18 LOAD_FAST                0 (a)
#              20 UNARY_INVERT
#              22 STORE_FAST               0 (a)
#              24 LOAD_CONST               0 (None)
#              26 RETURN_VALUE
```
```c
TARGET(UNARY_POSITIVE) {
    PyObject *value = TOP();
    PyObject *res = PyNumber_Positive(value);
    Py_DECREF(value);
    SET_TOP(res);
    if (res == NULL)
        goto error;
    DISPATCH();
}
```

## UNARY_NEGATIVE (a=-a)

与UNARY_POSITIVE相反

栈顶的元素调用该元素的`(o->ob_type->tp_as_number-->nb_negative)(o)`来获取其负数

```
TARGET(UNARY_NEGATIVE) {
    PyObject *value = TOP();
    PyObject *res = PyNumber_Negative(value);
    Py_DECREF(value);
    SET_TOP(res);
    if (res == NULL)
        goto error;
    DISPATCH();
}
```

## UNARY_NOT (a= not a)

如果a是True 那么栈顶设置为`Py_False`,否则栈顶设置为`Py_True`

```c
TARGET(UNARY_NOT) {
    PyObject *value = TOP();
    int err = PyObject_IsTrue(value);
    Py_DECREF(value);
    if (err == 0) {
        Py_INCREF(Py_True);
        SET_TOP(Py_True);
        DISPATCH();
    }
    else if (err > 0) {
        Py_INCREF(Py_False);
        SET_TOP(Py_False);
        err = 0;
        DISPATCH();
    }
    STACKADJ(-1);
    goto error;
}
```

## UNARY_INVERT (a=~a)

栈顶的元素调用该元素的`(o->ob_type->tp_as_number-->nb_invert)(o)`

```c
TARGET(UNARY_INVERT) {
    PyObject *value = TOP();
    PyObject *res = PyNumber_Invert(value);
    Py_DECREF(value);
    SET_TOP(res);
    if (res == NULL)
        goto error;
    DISPATCH();
}
```

## BINARY_POWER (a=a**b)

指数
```c
TARGET(BINARY_POWER) {
    PyObject *exp = POP();
    PyObject *base = TOP();
    PyObject *res = PyNumber_Power(base, exp, Py_None);
    Py_DECREF(base);
    Py_DECREF(exp);
    SET_TOP(res);
    if (res == NULL)
        goto error;
    DISPATCH();
}
```

## BINARY_MULTIPLY (a=a*b)

乘法

```c
TARGET(BINARY_MULTIPLY) {
    PyObject *right = POP();
    PyObject *left = TOP();
    PyObject *res = PyNumber_Multiply(left, right);
    Py_DECREF(left);
    Py_DECREF(right);
    SET_TOP(res);
    if (res == NULL)
        goto error;
    DISPATCH();
}
```

## BINARY\_MATRIX\_MULTIPLY(a=a@b)

矩阵相乘

```
TARGET(BINARY_MATRIX_MULTIPLY) {
    PyObject *right = POP();
    PyObject *left = TOP();
    PyObject *res = PyNumber_MatrixMultiply(left, right);
    Py_DECREF(left);
    Py_DECREF(right);
    SET_TOP(res);
    if (res == NULL)
        goto error;
    DISPATCH();
}
```

## BINARY\_TRUE\_DIVIDE (a=a/b)

`10/3 --> 3.3333333333333335`

```c
TARGET(BINARY_TRUE_DIVIDE) {
    PyObject *divisor = POP();
    PyObject *dividend = TOP();
    PyObject *quotient = PyNumber_TrueDivide(dividend, divisor);
    Py_DECREF(dividend);
    Py_DECREF(divisor);
    SET_TOP(quotient);
    if (quotient == NULL)
        goto error;
    DISPATCH();
}
```

## BINARY\_FLOOR\_DIVIDE(a=a//b)

`10//3 --> 3`

```c
TARGET(BINARY_FLOOR_DIVIDE) {
    PyObject *divisor = POP();
    PyObject *dividend = TOP();
    PyObject *quotient = PyNumber_FloorDivide(dividend, divisor);
    Py_DECREF(dividend);
    Py_DECREF(divisor);
    SET_TOP(quotient);
    if (quotient == NULL)
        goto error;
    DISPATCH();
}
```

## BINARY_MODULO (a=a%b)

余数 `10%3 ---> 1`

**如果这里获取的dividend是字符串,那么说明可能字符串格式化**

```c
TARGET(BINARY_MODULO) {
    PyObject *divisor = POP();
    PyObject *dividend = TOP();
    PyObject *res;
    if (PyUnicode_CheckExact(dividend) && (
            !PyUnicode_Check(divisor) || PyUnicode_CheckExact(divisor))) {
        // fast path; string formatting, but not if the RHS is a str subclass
        // (see issue28598)
        res = PyUnicode_Format(dividend, divisor);
    } else {
        res = PyNumber_Remainder(dividend, divisor);
    }
    Py_DECREF(divisor);
    Py_DECREF(dividend);
    SET_TOP(res);
    if (res == NULL)
        goto error;
    DISPATCH();
}
```

## BINARY_ADD(a=a+b)

**加法操作要判断是否是字符串相加**

```c
TARGET(BINARY_ADD) {
    PyObject *right = POP();
    PyObject *left = TOP();
    PyObject *sum;
    if (PyUnicode_CheckExact(left) &&
                PyUnicode_CheckExact(right)) {
        sum = unicode_concatenate(left, right, f, next_instr);
        /* unicode_concatenate consumed the ref to left */
    }
    else {
        sum = PyNumber_Add(left, right);
        Py_DECREF(left);
    }
    Py_DECREF(right);
    SET_TOP(sum);
    if (sum == NULL)
        goto error;
    DISPATCH();
}
```

## BINARY_SUBTRACT(a=a-b)

减法操作

```c
TARGET(BINARY_SUBTRACT) {
    PyObject *right = POP();
    PyObject *left = TOP();
    PyObject *diff = PyNumber_Subtract(left, right);
    Py_DECREF(right);
    Py_DECREF(left);
    SET_TOP(diff);
    if (diff == NULL)
        goto error;
    DISPATCH();
}
```

## BINARY_SUBSCR (a=a[sub])

获取指定位置的元素

指定键对应的元素(`o->ob_type->tp_as_mapping->mp_subscript(o,key)`)

```c
PyObject *
PyObject_GetItem(PyObject *o, PyObject *key)
{
    PyMappingMethods *m;

    if (o == NULL || key == NULL) {
        return null_error();
    }

    m = o->ob_type->tp_as_mapping;
    if (m && m->mp_subscript) {
        PyObject *item = m->mp_subscript(o, key);
        assert((item != NULL) ^ (PyErr_Occurred() != NULL));
        return item;
    }

    if (o->ob_type->tp_as_sequence) {
        if (PyIndex_Check(key)) {
            // 这里检查对象(key)->ob_type->tp_as_number != NULL && (key)->ob_type->tp_as_number->nb_index != NULL)

            Py_ssize_t key_value;
            // 将key转换为Py_ssize_t就64位整数
            key_value = PyNumber_AsSsize_t(key, PyExc_IndexError);
            if (key_value == -1 && PyErr_Occurred())
                return NULL;
            // o->ob_type->tp_as_sequence->sq_item(o, key_value)
            return PySequence_GetItem(o, key_value);
        }
        else if (o->ob_type->tp_as_sequence->sq_item)
            return type_error("sequence index must "
                              "be integer, not '%.200s'", key);
    }

    return type_error("'%.200s' object is not subscriptable", o);
}
```
```c
TARGET(BINARY_SUBSCR) {
    PyObject *sub = POP();
    PyObject *container = TOP();
    PyObject *res = PyObject_GetItem(container, sub);
    Py_DECREF(container);
    Py_DECREF(sub);
    SET_TOP(res);
    if (res == NULL)
        goto error;
    DISPATCH();
}
```

## BINARY_LSHIFT(a=a<<b)

左移

```c
TARGET(BINARY_LSHIFT) {
    PyObject *right = POP();
    PyObject *left = TOP();
    PyObject *res = PyNumber_Lshift(left, right);
    Py_DECREF(left);
    Py_DECREF(right);
    SET_TOP(res);
    if (res == NULL)
        goto error;
    DISPATCH();
}
```
##  BINARY_RSHIFT (a= a>>b)

右移
```c
TARGET(BINARY_RSHIFT) {
    PyObject *right = POP();
    PyObject *left = TOP();
    PyObject *res = PyNumber_Rshift(left, right);
    Py_DECREF(left);
    Py_DECREF(right);
    SET_TOP(res);
    if (res == NULL)
        goto error;
    DISPATCH();
}
```

## BINARY_AND(a=a&b)

按位与
```c
TARGET(BINARY_AND) {
    PyObject *right = POP();
    PyObject *left = TOP();
    PyObject *res = PyNumber_And(left, right);
    Py_DECREF(left);
    Py_DECREF(right);
    SET_TOP(res);
    if (res == NULL)
        goto error;
    DISPATCH();
}
```

## BINARY_XOR(a=a^b)

按位异或

```c
TARGET(BINARY_XOR) {
    PyObject *right = POP();
    PyObject *left = TOP();
    PyObject *res = PyNumber_Xor(left, right);
    Py_DECREF(left);
    Py_DECREF(right);
    SET_TOP(res);
    if (res == NULL)
        goto error;
    DISPATCH();
}
```

## BINARY_OR(a=a|b)

按位或

```c
TARGET(BINARY_OR) {
    PyObject *right = POP();
    PyObject *left = TOP();
    PyObject *res = PyNumber_Or(left, right);
    Py_DECREF(left);
    Py_DECREF(right);
    SET_TOP(res);
    if (res == NULL)
        goto error;
    DISPATCH();
}
```

## LIST_APPEND (a.append(b))

向数组中添加元素

取出栈顶元素添加到数组尾部

```c
TARGET(LIST_APPEND) {
    PyObject *v = POP();
    PyObject *list = PEEK(oparg);
    int err;
    err = PyList_Append(list, v);
    Py_DECREF(v);
    if (err != 0)
        goto error;
    PREDICT(JUMP_ABSOLUTE);
    DISPATCH();
}
```

## SET_ADD(a.add())

向集合中添加元素

```c
TARGET(SET_ADD) {
    PyObject *v = POP();
    PyObject *set = stack_pointer[-oparg];
    int err;
    err = PySet_Add(set, v);
    Py_DECREF(v);
    if (err != 0)
        goto error;
    PREDICT(JUMP_ABSOLUTE);
    DISPATCH();
}
```

## INPLACE_op (对应指令op的a+=a)

-    INPLACE_POWER
-    INPLACE_MULTIPLY
-    INPLACE\_MATRIX\_MULTIPLY
-    INPLACE\_TRUE\_DIVIDE
-    INPLACE\_FLOOR\_DIVIDE
-    INPLACE_MODULO
-    INPLACE_ADD
-    INPLACE_SUBTRACT
-    INPLACE_LSHIFT
-    INPLACE_RSHIFT
-    INPLACE_AND
-    INPLACE_XOR
-    INPLACE_OR

## STORE_SUBSCR (a[sub]=b)

设置指定位置的值

```c
TARGET(STORE_SUBSCR) {
    PyObject *sub = TOP();
    PyObject *container = SECOND();
    PyObject *v = THIRD();
    int err;
    STACKADJ(-3);
    /* container[sub] = v */
    err = PyObject_SetItem(container, sub, v);
    Py_DECREF(v);
    Py_DECREF(container);
    Py_DECREF(sub);
    if (err != 0)
        goto error;
    DISPATCH();
}
```
## STORE_ANNOTATION(3.6提供的指令)

`Stores TOS as locals()['__annotations__'][co_names[namei]] = TOS.`

```c
TARGET(STORE_ANNOTATION) {
    _Py_IDENTIFIER(__annotations__);
    PyObject *ann_dict;
    PyObject *ann = POP();
    PyObject *name = GETITEM(names, oparg);
    int err;
    if (f->f_locals == NULL) {
        PyErr_Format(PyExc_SystemError,
                        "no locals found when storing annotation");
        Py_DECREF(ann);
        goto error;
    }
    /* first try to get __annotations__ from locals... */
    if (PyDict_CheckExact(f->f_locals)) {
        ann_dict = _PyDict_GetItemId(f->f_locals,
                                        &PyId___annotations__);
        if (ann_dict == NULL) {
            PyErr_SetString(PyExc_NameError,
                            "__annotations__ not found");
            Py_DECREF(ann);
            goto error;
        }
        Py_INCREF(ann_dict);
    }
    else {
        PyObject *ann_str = _PyUnicode_FromId(&PyId___annotations__);
        if (ann_str == NULL) {
            Py_DECREF(ann);
            goto error;
        }
        ann_dict = PyObject_GetItem(f->f_locals, ann_str);
        if (ann_dict == NULL) {
            if (PyErr_ExceptionMatches(PyExc_KeyError)) {
                PyErr_SetString(PyExc_NameError,
                                "__annotations__ not found");
            }
            Py_DECREF(ann);
            goto error;
        }
    }
    /* ...if succeeded, __annotations__[name] = ann */
    if (PyDict_CheckExact(ann_dict)) {
        err = PyDict_SetItem(ann_dict, name, ann);
    }
    else {
        err = PyObject_SetItem(ann_dict, name, ann);
    }
    Py_DECREF(ann_dict);
    Py_DECREF(ann);
    if (err != 0) {
        goto error;
    }
    DISPATCH();
}
```

## DELETE_SUBSCR (del a[sub])

删除数组中的元素,或者字典中的元素

```c
TARGET(DELETE_SUBSCR) {
    PyObject *sub = TOP();
    PyObject *container = SECOND();
    int err;
    STACKADJ(-2);
    /* del container[sub] */
    err = PyObject_DelItem(container, sub);
    Py_DECREF(container);
    Py_DECREF(sub);
    if (err != 0)
        goto error;
    DISPATCH();
}
```

## PRINT_EXPR

交互模式下会使用,用于打印对象的信息,如果不是交互模式,那么直接pop掉该元素

```c
TARGET(PRINT_EXPR) {
    _Py_IDENTIFIER(displayhook);
    PyObject *value = POP();
    PyObject *hook = _PySys_GetObjectId(&PyId_displayhook);
    PyObject *res;
    if (hook == NULL) {
        PyErr_SetString(PyExc_RuntimeError,
                        "lost sys.displayhook");
        Py_DECREF(value);
        goto error;
    }
    res = PyObject_CallFunctionObjArgs(hook, value, NULL);
    Py_DECREF(value);
    if (res == NULL)
        goto error;
    Py_DECREF(res);
    DISPATCH();
}
```

## RAISE_VARARGS

抛出异常

python3.6 中抛出异常的3种方式

1. raise 对一个 opargs=0 
2. raise exception (args)  对应 opargs=1 
4. raise exception (args) from original_exception 对应 opargs=2


```python 
def test(a):
    raise Exception('d')
    raise Exception
    raise
    raise Exception from AttributeError

# 2           0 LOAD_GLOBAL              0 (Exception)
#             2 LOAD_CONST               1 ('d')
#             4 CALL_FUNCTION            1
#             6 RAISE_VARARGS            1

# 3           8 LOAD_GLOBAL              0 (Exception)
#             10 RAISE_VARARGS            1

# 4          12 RAISE_VARARGS            0

# 5          14 LOAD_GLOBAL              0 (Exception)
#             16 LOAD_GLOBAL              1 (AttributeError)
#             18 RAISE_VARARGS            2
#             20 LOAD_CONST               0 (None)
#             22 RETURN_VALUE
```

```c
TARGET(RAISE_VARARGS) {
    PyObject *cause = NULL, *exc = NULL;
    switch (oparg) {
    case 2:
        cause = POP(); /* cause */
        /* fall through */
    case 1:
        exc = POP(); /* exc */
        /* fall through */
    case 0:
        if (do_raise(exc, cause)) {
            why = WHY_EXCEPTION;
            goto fast_block_end;
        }
        break;
    default:
        PyErr_SetString(PyExc_SystemError,
                    "bad RAISE_VARARGS oparg");
        break;
    }
    goto error;
}
```

## RETURN_VALUE

将栈顶元素取出来,并退出当前frame

```c
TARGET(RETURN_VALUE) {
    retval = POP();
    why = WHY_RETURN;
    goto fast_block_end;
}
```

## GET_AITER


```c
TARGET(GET_AITER) {
    unaryfunc getter = NULL;
    PyObject *iter = NULL;
    PyObject *awaitable = NULL;
    PyObject *obj = TOP();
    PyTypeObject *type = Py_TYPE(obj);

    if (type->tp_as_async != NULL) {
        getter = type->tp_as_async->am_aiter;
    }

    if (getter != NULL) {
        iter = (*getter)(obj);
        Py_DECREF(obj);
        if (iter == NULL) {
            SET_TOP(NULL);
            goto error;
        }
    }
    else {
        SET_TOP(NULL);
        PyErr_Format(
            PyExc_TypeError,
            "'async for' requires an object with "
            "__aiter__ method, got %.100s",
            type->tp_name);
        Py_DECREF(obj);
        goto error;
    }

    if (Py_TYPE(iter)->tp_as_async != NULL &&
            Py_TYPE(iter)->tp_as_async->am_anext != NULL) {

        /* Starting with CPython 3.5.2 __aiter__ should return
            asynchronous iterators directly (not awaitables that
            resolve to asynchronous iterators.)

            Therefore, we check if the object that was returned
            from __aiter__ has an __anext__ method.  If it does,
            we wrap it in an awaitable that resolves to `iter`.

            See http://bugs.python.org/issue27243 for more
            details.
        */

        PyObject *wrapper = _PyAIterWrapper_New(iter);
        Py_DECREF(iter);
        SET_TOP(wrapper);
        DISPATCH();
    }

    awaitable = _PyCoro_GetAwaitableIter(iter);
    if (awaitable == NULL) {
        _PyErr_FormatFromCause(
            PyExc_TypeError,
            "'async for' received an invalid object "
            "from __aiter__: %.100s",
            Py_TYPE(iter)->tp_name);

        SET_TOP(NULL);
        Py_DECREF(iter);
        goto error;
    } else {
        Py_DECREF(iter);

        if (PyErr_WarnFormat(
                PyExc_DeprecationWarning, 1,
                "'%.100s' implements legacy __aiter__ protocol; "
                "__aiter__ should return an asynchronous "
                "iterator, not awaitable",
                type->tp_name))
        {
            /* Warning was converted to an error. */
            Py_DECREF(awaitable);
            SET_TOP(NULL);
            goto error;
        }
    }

    SET_TOP(awaitable);
    PREDICT(LOAD_CONST);
    DISPATCH();
}
```
```c
TARGET(GET_ANEXT) {
    unaryfunc getter = NULL;
    PyObject *next_iter = NULL;
    PyObject *awaitable = NULL;
    PyObject *aiter = TOP();
    PyTypeObject *type = Py_TYPE(aiter);

    if (PyAsyncGen_CheckExact(aiter)) {
        awaitable = type->tp_as_async->am_anext(aiter);
        if (awaitable == NULL) {
            goto error;
        }
    } else {
        if (type->tp_as_async != NULL){
            getter = type->tp_as_async->am_anext;
        }

        if (getter != NULL) {
            next_iter = (*getter)(aiter);
            if (next_iter == NULL) {
                goto error;
            }
        }
        else {
            PyErr_Format(
                PyExc_TypeError,
                "'async for' requires an iterator with "
                "__anext__ method, got %.100s",
                type->tp_name);
            goto error;
        }

        awaitable = _PyCoro_GetAwaitableIter(next_iter);
        if (awaitable == NULL) {
            _PyErr_FormatFromCause(
                PyExc_TypeError,
                "'async for' received an invalid object "
                "from __anext__: %.100s",
                Py_TYPE(next_iter)->tp_name);

            Py_DECREF(next_iter);
            goto error;
        } else {
            Py_DECREF(next_iter);
        }
    }

    PUSH(awaitable);
    PREDICT(LOAD_CONST);
    DISPATCH();
}

PREDICTED(GET_AWAITABLE);
TARGET(GET_AWAITABLE) {
    PyObject *iterable = TOP();
    PyObject *iter = _PyCoro_GetAwaitableIter(iterable);

    Py_DECREF(iterable);

    if (iter != NULL && PyCoro_CheckExact(iter)) {
        PyObject *yf = _PyGen_yf((PyGenObject*)iter);
        if (yf != NULL) {
            /* `iter` is a coroutine object that is being
                awaited, `yf` is a pointer to the current awaitable
                being awaited on. */
            Py_DECREF(yf);
            Py_CLEAR(iter);
            PyErr_SetString(
                PyExc_RuntimeError,
                "coroutine is being awaited already");
            /* The code below jumps to `error` if `iter` is NULL. */
        }
    }

    SET_TOP(iter); /* Even if it's NULL */

    if (iter == NULL) {
        goto error;
    }

    PREDICT(LOAD_CONST);
    DISPATCH();
}
```

## YIELD_FROM 

获取gen的下一个元素
```c
TARGET(YIELD_FROM) {
    PyObject *v = POP();
    PyObject *receiver = TOP();
    int err;
    if (PyGen_CheckExact(receiver) || PyCoro_CheckExact(receiver)) {
        retval = _PyGen_Send((PyGenObject *)receiver, v);
    } else {
        _Py_IDENTIFIER(send);
        if (v == Py_None)
            retval = Py_TYPE(receiver)->tp_iternext(receiver);
        else
            retval = _PyObject_CallMethodIdObjArgs(receiver, &PyId_send, v, NULL);
    }
    Py_DECREF(v);
    if (retval == NULL) {
        PyObject *val;
        if (tstate->c_tracefunc != NULL
                && PyErr_ExceptionMatches(PyExc_StopIteration))
            call_exc_trace(tstate->c_tracefunc, tstate->c_traceobj, tstate, f);
        err = _PyGen_FetchStopIterationValue(&val);
        if (err < 0)
            goto error;
        Py_DECREF(receiver);
        SET_TOP(val);
        DISPATCH();
    }
    /* receiver remains on stack, retval is value to be yielded */
    f->f_stacktop = stack_pointer;
    why = WHY_YIELD;
    /* and repeat... */
    assert(f->f_lasti >= (int)sizeof(_Py_CODEUNIT));
    f->f_lasti -= sizeof(_Py_CODEUNIT);
    goto fast_yield;
}
```

## YIELD_VALUE

创建一个gen

```c
TARGET(YIELD_VALUE) {
    retval = POP();
    if (co->co_flags & CO_ASYNC_GENERATOR) {
        PyObject *w = _PyAsyncGenValueWrapperNew(retval);
        Py_DECREF(retval);
        if (w == NULL) {
            retval = NULL;
            goto error;
        }
        retval = w;
    }

    f->f_stacktop = stack_pointer;
    why = WHY_YIELD;
    goto fast_yield;
}
```

## POP_EXCEPT

取出当前frame中的一个block`b = &f->f_blockstack[--f->f_iblock];`
```c
TARGET(POP_EXCEPT) {
    PyTryBlock *b = PyFrame_BlockPop(f);
    if (b->b_type != EXCEPT_HANDLER) {
        PyErr_SetString(PyExc_SystemError,
                        "popped block is not an except handler");
        goto error;
    }
    UNWIND_EXCEPT_HANDLER(b);
    DISPATCH();
}
```

## POP_BLOCK

取出当前frame中的一个block`b = &f->f_blockstack[--f->f_iblock];`

```c

TARGET(POP_BLOCK) {
    PyTryBlock *b = PyFrame_BlockPop(f);
    UNWIND_BLOCK(b);
    DISPATCH();
}
```

## END_FINALLY

结束finally语句,检查是否需要继续抛出异常,
```c
TARGET(END_FINALLY) {
    PyObject *status = POP();
    if (PyLong_Check(status)) {
        why = (enum why_code) PyLong_AS_LONG(status);
        assert(why != WHY_YIELD && why != WHY_EXCEPTION);
        if (why == WHY_RETURN ||
            why == WHY_CONTINUE)
            retval = POP();
        if (why == WHY_SILENCED) {
            /* An exception was silenced by 'with', we must
            manually unwind the EXCEPT_HANDLER block which was
            created when the exception was caught, otherwise
            the stack will be in an inconsistent state. */
            PyTryBlock *b = PyFrame_BlockPop(f);
            assert(b->b_type == EXCEPT_HANDLER);
            UNWIND_EXCEPT_HANDLER(b);
            why = WHY_NOT;
            Py_DECREF(status);
            DISPATCH();
        }
        Py_DECREF(status);
        goto fast_block_end;
    }
    else if (PyExceptionClass_Check(status)) {
        PyObject *exc = POP();
        PyObject *tb = POP();
        PyErr_Restore(status, exc, tb);
        why = WHY_EXCEPTION;
        goto fast_block_end;
    }
    else if (status != Py_None) {
        PyErr_SetString(PyExc_SystemError,
            "'finally' pops bad exception");
        Py_DECREF(status);
        goto error;
    }
    Py_DECREF(status);
    DISPATCH();
}
```

## LOAD\_BUILD\_CLASS

将内置方法`__build_class__`压入栈中

```c
TARGET(LOAD_BUILD_CLASS) {
    _Py_IDENTIFIER(__build_class__);

    PyObject *bc;
    if (PyDict_CheckExact(f->f_builtins)) {
        bc = _PyDict_GetItemId(f->f_builtins, &PyId___build_class__);
        if (bc == NULL) {
            PyErr_SetString(PyExc_NameError,
                            "__build_class__ not found");
            goto error;
        }
        Py_INCREF(bc);
    }
    else {
        PyObject *build_class_str = _PyUnicode_FromId(&PyId___build_class__);
        if (build_class_str == NULL)
            goto error;
        bc = PyObject_GetItem(f->f_builtins, build_class_str);
        if (bc == NULL) {
            if (PyErr_ExceptionMatches(PyExc_KeyError))
                PyErr_SetString(PyExc_NameError,
                                "__build_class__ not found");
            goto error;
        }
    }
    PUSH(bc);
    DISPATCH();
}
```

## STORE_NAME

将值保存到f_locals中
```c
TARGET(STORE_NAME) {
    PyObject *name = GETITEM(names, oparg);
    PyObject *v = POP();
    PyObject *ns = f->f_locals;
    int err;
    if (ns == NULL) {
        PyErr_Format(PyExc_SystemError,
                        "no locals found when storing %R", name);
        Py_DECREF(v);
        goto error;
    }
    if (PyDict_CheckExact(ns))
        err = PyDict_SetItem(ns, name, v);
    else
        err = PyObject_SetItem(ns, name, v);
    Py_DECREF(v);
    if (err != 0)
        goto error;
    DISPATCH();
}
```

## DELETE_NAME

从f_locals伤处变量
```c
TARGET(DELETE_NAME) {
    PyObject *name = GETITEM(names, oparg);
    PyObject *ns = f->f_locals;
    int err;
    if (ns == NULL) {
        PyErr_Format(PyExc_SystemError,
                        "no locals when deleting %R", name);
        goto error;
    }
    err = PyObject_DelItem(ns, name);
    if (err != 0) {
        format_exc_check_arg(PyExc_NameError,
                                NAME_ERROR_MSG,
                                name);
        goto error;
    }
    DISPATCH();
}
```

## UNPACK_SEQUENCE

将容器中的元素全部压入栈中

```c
TARGET(UNPACK_SEQUENCE) {
    PyObject *seq = POP(), *item, **items;
    if (PyTuple_CheckExact(seq) &&
        PyTuple_GET_SIZE(seq) == oparg) {
        items = ((PyTupleObject *)seq)->ob_item;
        while (oparg--) {
            item = items[oparg];
            Py_INCREF(item);
            PUSH(item);
        }
    } else if (PyList_CheckExact(seq) &&
                PyList_GET_SIZE(seq) == oparg) {
        items = ((PyListObject *)seq)->ob_item;
        while (oparg--) {
            item = items[oparg];
            Py_INCREF(item);
            PUSH(item);
        }
    } else if (unpack_iterable(seq, oparg, -1,
                                stack_pointer + oparg)) {
        STACKADJ(oparg);
    } else {
        /* unpack_iterable() raised an exception */
        Py_DECREF(seq);
        goto error;
    }
    Py_DECREF(seq);
    DISPATCH();
}
```

## UNPACK_EX

将某个容器对象中的totalargs数量的元素压入栈中
```c
TARGET(UNPACK_EX) {
    int totalargs = 1 + (oparg & 0xFF) + (oparg >> 8);
    PyObject *seq = POP();

    if (unpack_iterable(seq, oparg & 0xFF, oparg >> 8,
                        stack_pointer + totalargs)) {
        stack_pointer += totalargs;
    } else {
        Py_DECREF(seq);
        goto error;
    }
    Py_DECREF(seq);
    DISPATCH();
}
```

## STORE_ATTR

为对象属性赋值

```c
TARGET(STORE_ATTR) {
    PyObject *name = GETITEM(names, oparg);
    PyObject *owner = TOP();
    PyObject *v = SECOND();
    int err;
    STACKADJ(-2);
    err = PyObject_SetAttr(owner, name, v);
    Py_DECREF(v);
    Py_DECREF(owner);
    if (err != 0)
        goto error;
    DISPATCH();
}
```

## DELETE_ATTR

将对象的属性设置为空指针

```c
TARGET(DELETE_ATTR) {
    PyObject *name = GETITEM(names, oparg);
    PyObject *owner = POP();
    int err;
    err = PyObject_SetAttr(owner, name, (PyObject *)NULL);
    Py_DECREF(owner);
    if (err != 0)
        goto error;
    DISPATCH();
}
```

## STORE_GLOBAL

将name和v 设置到f_globals中
```
TARGET(STORE_GLOBAL) {
    PyObject *name = GETITEM(names, oparg);
    PyObject *v = POP();
    int err;
    err = PyDict_SetItem(f->f_globals, name, v);
    Py_DECREF(v);
    if (err != 0)
        goto error;
    DISPATCH();
}
```

## DELETE_GLOBAL

将f_globals中建name删除掉,就是置为NULL
```c
TARGET(DELETE_GLOBAL) {
    PyObject *name = GETITEM(names, oparg);
    int err;
    err = PyDict_DelItem(f->f_globals, name);
    if (err != 0) {
        format_exc_check_arg(
            PyExc_NameError, NAME_ERROR_MSG, name);
        goto error;
    }
    DISPATCH();
}
```

## LOAD_NAME

从`f_locals-->f_globals-->f_builtins`找到name对应的值

```c
TARGET(LOAD_NAME) {
    PyObject *name = GETITEM(names, oparg);
    PyObject *locals = f->f_locals;
    PyObject *v;
    if (locals == NULL) {
        PyErr_Format(PyExc_SystemError,
                        "no locals when loading %R", name);
        goto error;
    }
    if (PyDict_CheckExact(locals)) {
        v = PyDict_GetItem(locals, name);
        Py_XINCREF(v);
    }
    else {
        v = PyObject_GetItem(locals, name);
        if (v == NULL) {
            if (!PyErr_ExceptionMatches(PyExc_KeyError))
                goto error;
            PyErr_Clear();
        }
    }
    if (v == NULL) {
        v = PyDict_GetItem(f->f_globals, name);
        Py_XINCREF(v);
        if (v == NULL) {
            if (PyDict_CheckExact(f->f_builtins)) {
                v = PyDict_GetItem(f->f_builtins, name);
                if (v == NULL) {
                    format_exc_check_arg(
                                PyExc_NameError,
                                NAME_ERROR_MSG, name);
                    goto error;
                }
                Py_INCREF(v);
            }
            else {
                v = PyObject_GetItem(f->f_builtins, name);
                if (v == NULL) {
                    if (PyErr_ExceptionMatches(PyExc_KeyError))
                        format_exc_check_arg(
                                    PyExc_NameError,
                                    NAME_ERROR_MSG, name);
                    goto error;
                }
            }
        }
    }
    PUSH(v);
    DISPATCH();
}
```

## LOAD_GLOBAL

从f_globals中取值

```c
TARGET(LOAD_GLOBAL) {
    PyObject *name = GETITEM(names, oparg);
    PyObject *v;
    if (PyDict_CheckExact(f->f_globals)
        && PyDict_CheckExact(f->f_builtins))
    {
        v = _PyDict_LoadGlobal((PyDictObject *)f->f_globals,
                                (PyDictObject *)f->f_builtins,
                                name);
        if (v == NULL) {
            if (!_PyErr_OCCURRED()) {
                /* _PyDict_LoadGlobal() returns NULL without raising
                    * an exception if the key doesn't exist */
                format_exc_check_arg(PyExc_NameError,
                                        NAME_ERROR_MSG, name);
            }
            goto error;
        }
        Py_INCREF(v);
    }
    else {
        /* Slow-path if globals or builtins is not a dict */

        /* namespace 1: globals */
        v = PyObject_GetItem(f->f_globals, name);
        if (v == NULL) {
            if (!PyErr_ExceptionMatches(PyExc_KeyError))
                goto error;
            PyErr_Clear();

            /* namespace 2: builtins */
            v = PyObject_GetItem(f->f_builtins, name);
            if (v == NULL) {
                if (PyErr_ExceptionMatches(PyExc_KeyError))
                    format_exc_check_arg(
                                PyExc_NameError,
                                NAME_ERROR_MSG, name);
                goto error;
            }
        }
    }
    PUSH(v);
    DISPATCH();
}
```

## DELETE_FAST

删除函数中变量 co_varnames[oparg]=NULL
```c
TARGET(DELETE_FAST) {
    PyObject *v = GETLOCAL(oparg);
    if (v != NULL) {
        SETLOCAL(oparg, NULL);
        DISPATCH();
    }
    format_exc_check_arg(
        PyExc_UnboundLocalError,
        UNBOUNDLOCAL_ERROR_MSG,
        PyTuple_GetItem(co->co_varnames, oparg)
        );
    goto error;
}
```

## DELETE_DEREF

删除函数中变量 freevars[oparg]=NULL

```c
TARGET(DELETE_DEREF) {
    PyObject *cell = freevars[oparg];
    if (PyCell_GET(cell) != NULL) {
        PyCell_Set(cell, NULL);
        DISPATCH();
    }
    format_exc_unbound(co, oparg);
    goto error;
}
```

## LOAD_CLOSURE

freevars[oparg]压入栈中
```c
TARGET(LOAD_CLOSURE) {
    PyObject *cell = freevars[oparg];
    Py_INCREF(cell);
    PUSH(cell);
    DISPATCH();
}
```

## LOAD_CLASSDEREF

```c
TARGET(LOAD_CLASSDEREF) {
    PyObject *name, *value, *locals = f->f_locals;
    Py_ssize_t idx;
    assert(locals);
    assert(oparg >= PyTuple_GET_SIZE(co->co_cellvars));
    idx = oparg - PyTuple_GET_SIZE(co->co_cellvars);
    assert(idx >= 0 && idx < PyTuple_GET_SIZE(co->co_freevars));
    name = PyTuple_GET_ITEM(co->co_freevars, idx);
    if (PyDict_CheckExact(locals)) {
        value = PyDict_GetItem(locals, name);
        Py_XINCREF(value);
    }
    else {
        value = PyObject_GetItem(locals, name);
        if (value == NULL) {
            if (!PyErr_ExceptionMatches(PyExc_KeyError))
                goto error;
            PyErr_Clear();
        }
    }
    if (!value) {
        PyObject *cell = freevars[oparg];
        value = PyCell_GET(cell);
        if (value == NULL) {
            format_exc_unbound(co, oparg);
            goto error;
        }
        Py_INCREF(value);
    }
    PUSH(value);
    DISPATCH();
}
```
TARGET(LOAD_DEREF) {
    PyObject *cell = freevars[oparg];
    PyObject *value = PyCell_GET(cell);
    if (value == NULL) {
        format_exc_unbound(co, oparg);
        goto error;
    }
    Py_INCREF(value);
    PUSH(value);
    DISPATCH();
}

TARGET(STORE_DEREF) {
    PyObject *v = POP();
    PyObject *cell = freevars[oparg];
    PyObject *oldobj = PyCell_GET(cell);
    PyCell_SET(cell, v);
    Py_XDECREF(oldobj);
    DISPATCH();
}

TARGET(BUILD_STRING) {
    PyObject *str;
    PyObject *empty = PyUnicode_New(0, 0);
    if (empty == NULL) {
        goto error;
    }
    str = _PyUnicode_JoinArray(empty, stack_pointer - oparg, oparg);
    Py_DECREF(empty);
    if (str == NULL)
        goto error;
    while (--oparg >= 0) {
        PyObject *item = POP();
        Py_DECREF(item);
    }
    PUSH(str);
    DISPATCH();
}

TARGET(BUILD_TUPLE) {
    PyObject *tup = PyTuple_New(oparg);
    if (tup == NULL)
        goto error;
    while (--oparg >= 0) {
        PyObject *item = POP();
        PyTuple_SET_ITEM(tup, oparg, item);
    }
    PUSH(tup);
    DISPATCH();
}

TARGET(BUILD_LIST) {
    PyObject *list =  PyList_New(oparg);
    if (list == NULL)
        goto error;
    while (--oparg >= 0) {
        PyObject *item = POP();
        PyList_SET_ITEM(list, oparg, item);
    }
    PUSH(list);
    DISPATCH();
}

TARGET(BUILD_TUPLE_UNPACK_WITH_CALL)
TARGET(BUILD_TUPLE_UNPACK)
TARGET(BUILD_LIST_UNPACK) {
    int convert_to_tuple = opcode != BUILD_LIST_UNPACK;
    Py_ssize_t i;
    PyObject *sum = PyList_New(0);
    PyObject *return_value;

    if (sum == NULL)
        goto error;

    for (i = oparg; i > 0; i--) {
        PyObject *none_val;

        none_val = _PyList_Extend((PyListObject *)sum, PEEK(i));
        if (none_val == NULL) {
            if (opcode == BUILD_TUPLE_UNPACK_WITH_CALL &&
                PyErr_ExceptionMatches(PyExc_TypeError))
            {
                check_args_iterable(PEEK(1 + oparg), PEEK(i));
            }
            Py_DECREF(sum);
            goto error;
        }
        Py_DECREF(none_val);
    }

    if (convert_to_tuple) {
        return_value = PyList_AsTuple(sum);
        Py_DECREF(sum);
        if (return_value == NULL)
            goto error;
    }
    else {
        return_value = sum;
    }

    while (oparg--)
        Py_DECREF(POP());
    PUSH(return_value);
    DISPATCH();
}

TARGET(BUILD_SET) {
    PyObject *set = PySet_New(NULL);
    int err = 0;
    int i;
    if (set == NULL)
        goto error;
    for (i = oparg; i > 0; i--) {
        PyObject *item = PEEK(i);
        if (err == 0)
            err = PySet_Add(set, item);
        Py_DECREF(item);
    }
    STACKADJ(-oparg);
    if (err != 0) {
        Py_DECREF(set);
        goto error;
    }
    PUSH(set);
    DISPATCH();
}

TARGET(BUILD_SET_UNPACK) {
    Py_ssize_t i;
    PyObject *sum = PySet_New(NULL);
    if (sum == NULL)
        goto error;

    for (i = oparg; i > 0; i--) {
        if (_PySet_Update(sum, PEEK(i)) < 0) {
            Py_DECREF(sum);
            goto error;
        }
    }

    while (oparg--)
        Py_DECREF(POP());
    PUSH(sum);
    DISPATCH();
}

TARGET(BUILD_MAP) {
    Py_ssize_t i;
    PyObject *map = _PyDict_NewPresized((Py_ssize_t)oparg);
    if (map == NULL)
        goto error;
    for (i = oparg; i > 0; i--) {
        int err;
        PyObject *key = PEEK(2*i);
        PyObject *value = PEEK(2*i - 1);
        err = PyDict_SetItem(map, key, value);
        if (err != 0) {
            Py_DECREF(map);
            goto error;
        }
    }

    while (oparg--) {
        Py_DECREF(POP());
        Py_DECREF(POP());
    }
    PUSH(map);
    DISPATCH();
}

TARGET(SETUP_ANNOTATIONS) {
    _Py_IDENTIFIER(__annotations__);
    int err;
    PyObject *ann_dict;
    if (f->f_locals == NULL) {
        PyErr_Format(PyExc_SystemError,
                        "no locals found when setting up annotations");
        goto error;
    }
    /* check if __annotations__ in locals()... */
    if (PyDict_CheckExact(f->f_locals)) {
        ann_dict = _PyDict_GetItemId(f->f_locals,
                                        &PyId___annotations__);
        if (ann_dict == NULL) {
            /* ...if not, create a new one */
            ann_dict = PyDict_New();
            if (ann_dict == NULL) {
                goto error;
            }
            err = _PyDict_SetItemId(f->f_locals,
                                    &PyId___annotations__, ann_dict);
            Py_DECREF(ann_dict);
            if (err != 0) {
                goto error;
            }
        }
    }
    else {
        /* do the same if locals() is not a dict */
        PyObject *ann_str = _PyUnicode_FromId(&PyId___annotations__);
        if (ann_str == NULL) {
            goto error;
        }
        ann_dict = PyObject_GetItem(f->f_locals, ann_str);
        if (ann_dict == NULL) {
            if (!PyErr_ExceptionMatches(PyExc_KeyError)) {
                goto error;
            }
            PyErr_Clear();
            ann_dict = PyDict_New();
            if (ann_dict == NULL) {
                goto error;
            }
            err = PyObject_SetItem(f->f_locals, ann_str, ann_dict);
            Py_DECREF(ann_dict);
            if (err != 0) {
                goto error;
            }
        }
        else {
            Py_DECREF(ann_dict);
        }
    }
    DISPATCH();
}

TARGET(BUILD_CONST_KEY_MAP) {
    Py_ssize_t i;
    PyObject *map;
    PyObject *keys = TOP();
    if (!PyTuple_CheckExact(keys) ||
        PyTuple_GET_SIZE(keys) != (Py_ssize_t)oparg) {
        PyErr_SetString(PyExc_SystemError,
                        "bad BUILD_CONST_KEY_MAP keys argument");
        goto error;
    }
    map = _PyDict_NewPresized((Py_ssize_t)oparg);
    if (map == NULL) {
        goto error;
    }
    for (i = oparg; i > 0; i--) {
        int err;
        PyObject *key = PyTuple_GET_ITEM(keys, oparg - i);
        PyObject *value = PEEK(i + 1);
        err = PyDict_SetItem(map, key, value);
        if (err != 0) {
            Py_DECREF(map);
            goto error;
        }
    }

    Py_DECREF(POP());
    while (oparg--) {
        Py_DECREF(POP());
    }
    PUSH(map);
    DISPATCH();
}

TARGET(BUILD_MAP_UNPACK) {
    Py_ssize_t i;
    PyObject *sum = PyDict_New();
    if (sum == NULL)
        goto error;

    for (i = oparg; i > 0; i--) {
        PyObject *arg = PEEK(i);
        if (PyDict_Update(sum, arg) < 0) {
            if (PyErr_ExceptionMatches(PyExc_AttributeError)) {
                PyErr_Format(PyExc_TypeError,
                        "'%.200s' object is not a mapping",
                        arg->ob_type->tp_name);
            }
            Py_DECREF(sum);
            goto error;
        }
    }

    while (oparg--)
        Py_DECREF(POP());
    PUSH(sum);
    DISPATCH();
}

TARGET(BUILD_MAP_UNPACK_WITH_CALL) {
    Py_ssize_t i;
    PyObject *sum = PyDict_New();
    if (sum == NULL)
        goto error;

    for (i = oparg; i > 0; i--) {
        PyObject *arg = PEEK(i);
        if (_PyDict_MergeEx(sum, arg, 2) < 0) {
            PyObject *func = PEEK(2 + oparg);
            if (PyErr_ExceptionMatches(PyExc_AttributeError)) {
                format_kwargs_mapping_error(func, arg);
            }
            else if (PyErr_ExceptionMatches(PyExc_KeyError)) {
                PyObject *exc, *val, *tb;
                PyErr_Fetch(&exc, &val, &tb);
                if (val && PyTuple_Check(val) && PyTuple_GET_SIZE(val) == 1) {
                    PyObject *key = PyTuple_GET_ITEM(val, 0);
                    if (!PyUnicode_Check(key)) {
                        PyErr_Format(PyExc_TypeError,
                                "%.200s%.200s keywords must be strings",
                                PyEval_GetFuncName(func),
                                PyEval_GetFuncDesc(func));
                    } else {
                        PyErr_Format(PyExc_TypeError,
                                "%.200s%.200s got multiple "
                                "values for keyword argument '%U'",
                                PyEval_GetFuncName(func),
                                PyEval_GetFuncDesc(func),
                                key);
                    }
                    Py_XDECREF(exc);
                    Py_XDECREF(val);
                    Py_XDECREF(tb);
                }
                else {
                    PyErr_Restore(exc, val, tb);
                }
            }
            Py_DECREF(sum);
            goto error;
        }
    }

    while (oparg--)
        Py_DECREF(POP());
    PUSH(sum);
    DISPATCH();
}

TARGET(MAP_ADD) {
    PyObject *key = TOP();
    PyObject *value = SECOND();
    PyObject *map;
    int err;
    STACKADJ(-2);
    map = stack_pointer[-oparg];  /* dict */
    assert(PyDict_CheckExact(map));
    err = PyDict_SetItem(map, key, value);  /* map[key] = value */
    Py_DECREF(value);
    Py_DECREF(key);
    if (err != 0)
        goto error;
    PREDICT(JUMP_ABSOLUTE);
    DISPATCH();
}

TARGET(LOAD_ATTR) {
    PyObject *name = GETITEM(names, oparg);
    PyObject *owner = TOP();
    PyObject *res = PyObject_GetAttr(owner, name);
    Py_DECREF(owner);
    SET_TOP(res);
    if (res == NULL)
        goto error;
    DISPATCH();
}

TARGET(COMPARE_OP) {
    PyObject *right = POP();
    PyObject *left = TOP();
    PyObject *res = cmp_outcome(oparg, left, right);
    Py_DECREF(left);
    Py_DECREF(right);
    SET_TOP(res);
    if (res == NULL)
        goto error;
    PREDICT(POP_JUMP_IF_FALSE);
    PREDICT(POP_JUMP_IF_TRUE);
    DISPATCH();
}

TARGET(IMPORT_NAME) {
    PyObject *name = GETITEM(names, oparg);
    // from function_test import test2, test
    // 这种情况下 LOAD_CONST 3 (('test2', 'test'))
    // fromlist就是元组指针
    // 如果是import os,math这种情况下字节码是
    //   11          56 LOAD_CONST               0 (0)
    //   58 LOAD_CONST               1 (None)
    //   60 IMPORT_NAME              5 (os)
    //   62 STORE_NAME               5 (os)
    //   64 LOAD_CONST               0 (0)
    //   66 LOAD_CONST               1 (None)
    //   68 IMPORT_NAME              6 (math)
    //   70 STORE_NAME               6 (math)
    // 拆开导入

    // 直接import时 fromlist==&None
    // 只有使用from .. import 时 fromlist才会指向元组
    PyObject *fromlist = POP();
    // TODO: level估计是指向module对象
    PyObject *level = TOP();
    PyObject *res;
    res = import_name(f, name, fromlist, level);
    Py_DECREF(level);
    Py_DECREF(fromlist);
    SET_TOP(res);
    if (res == NULL)
        goto error;
    DISPATCH();
}

TARGET(IMPORT_STAR) {
    PyObject *from = POP(), *locals;
    int err;
    if (PyFrame_FastToLocalsWithError(f) < 0) {
        Py_DECREF(from);
        goto error;
    }

    locals = f->f_locals;
    if (locals == NULL) {
        PyErr_SetString(PyExc_SystemError,
            "no locals found during 'import *'");
        Py_DECREF(from);
        goto error;
    }
    err = import_all_from(locals, from);
    PyFrame_LocalsToFast(f, 0);
    Py_DECREF(from);
    if (err != 0)
        goto error;
    DISPATCH();
}

TARGET(IMPORT_FROM) {
    PyObject *name = GETITEM(names, oparg);
    PyObject *from = TOP();
    PyObject *res;
    res = import_from(from, name);
    PUSH(res);
    if (res == NULL)
        goto error;
    DISPATCH();
}

TARGET(JUMP_FORWARD) {
    JUMPBY(oparg);
    FAST_DISPATCH();
}

PREDICTED(POP_JUMP_IF_FALSE);
TARGET(POP_JUMP_IF_FALSE) {
    PyObject *cond = POP();
    int err;
    if (cond == Py_True) {
        Py_DECREF(cond);
        FAST_DISPATCH();
    }
    if (cond == Py_False) {
        Py_DECREF(cond);
        JUMPTO(oparg);
        FAST_DISPATCH();
    }
    err = PyObject_IsTrue(cond);
    Py_DECREF(cond);
    if (err > 0)
        err = 0;
    else if (err == 0)
        JUMPTO(oparg);
    else
        goto error;
    DISPATCH();
}

PREDICTED(POP_JUMP_IF_TRUE);
TARGET(POP_JUMP_IF_TRUE) {
    PyObject *cond = POP();
    int err;
    if (cond == Py_False) {
        Py_DECREF(cond);
        FAST_DISPATCH();
    }
    if (cond == Py_True) {
        Py_DECREF(cond);
        JUMPTO(oparg);
        FAST_DISPATCH();
    }
    err = PyObject_IsTrue(cond);
    Py_DECREF(cond);
    if (err > 0) {
        err = 0;
        JUMPTO(oparg);
    }
    else if (err == 0)
        ;
    else
        goto error;
    DISPATCH();
}

TARGET(JUMP_IF_FALSE_OR_POP) {
    PyObject *cond = TOP();
    int err;
    if (cond == Py_True) {
        STACKADJ(-1);
        Py_DECREF(cond);
        FAST_DISPATCH();
    }
    if (cond == Py_False) {
        JUMPTO(oparg);
        FAST_DISPATCH();
    }
    err = PyObject_IsTrue(cond);
    if (err > 0) {
        STACKADJ(-1);
        Py_DECREF(cond);
        err = 0;
    }
    else if (err == 0)
        JUMPTO(oparg);
    else
        goto error;
    DISPATCH();
}

TARGET(JUMP_IF_TRUE_OR_POP) {
    PyObject *cond = TOP();
    int err;
    if (cond == Py_False) {
        STACKADJ(-1);
        Py_DECREF(cond);
        FAST_DISPATCH();
    }
    if (cond == Py_True) {
        JUMPTO(oparg);
        FAST_DISPATCH();
    }
    err = PyObject_IsTrue(cond);
    if (err > 0) {
        err = 0;
        JUMPTO(oparg);
    }
    else if (err == 0) {
        STACKADJ(-1);
        Py_DECREF(cond);
    }
    else
        goto error;
    DISPATCH();
}

PREDICTED(JUMP_ABSOLUTE);
TARGET(JUMP_ABSOLUTE) {
    JUMPTO(oparg);
#if FAST_LOOPS
    /* Enabling this path speeds-up all while and for-loops by bypassing
        the per-loop checks for signals.  By default, this should be turned-off
        because it prevents detection of a control-break in tight loops like
        "while 1: pass".  Compile with this option turned-on when you need
        the speed-up and do not need break checking inside tight loops (ones
        that contain only instructions ending with FAST_DISPATCH).
    */
    FAST_DISPATCH();
#else
    DISPATCH();
#endif
}

TARGET(GET_ITER) {
    /* before: [obj]; after [getiter(obj)] */
    PyObject *iterable = TOP();
    PyObject *iter = PyObject_GetIter(iterable);
    Py_DECREF(iterable);
    SET_TOP(iter);
    if (iter == NULL)
        goto error;
    PREDICT(FOR_ITER);
    PREDICT(CALL_FUNCTION);
    DISPATCH();
}

TARGET(GET_YIELD_FROM_ITER) {
    /* before: [obj]; after [getiter(obj)] */
    PyObject *iterable = TOP();
    PyObject *iter;
    if (PyCoro_CheckExact(iterable)) {
        /* `iterable` is a coroutine */
        if (!(co->co_flags & (CO_COROUTINE | CO_ITERABLE_COROUTINE))) {
            /* and it is used in a 'yield from' expression of a
                regular generator. */
            Py_DECREF(iterable);
            SET_TOP(NULL);
            PyErr_SetString(PyExc_TypeError,
                            "cannot 'yield from' a coroutine object "
                            "in a non-coroutine generator");
            goto error;
        }
    }
    else if (!PyGen_CheckExact(iterable)) {
        /* `iterable` is not a generator. */
        iter = PyObject_GetIter(iterable);
        Py_DECREF(iterable);
        SET_TOP(iter);
        if (iter == NULL)
            goto error;
    }
    PREDICT(LOAD_CONST);
    DISPATCH();
}

PREDICTED(FOR_ITER);
TARGET(FOR_ITER) {
    /* before: [iter]; after: [iter, iter()] *or* [] */
    PyObject *iter = TOP();
    PyObject *next = (*iter->ob_type->tp_iternext)(iter);
    if (next != NULL) {
        PUSH(next);
        PREDICT(STORE_FAST);
        PREDICT(UNPACK_SEQUENCE);
        DISPATCH();
    }
    if (PyErr_Occurred()) {
        if (!PyErr_ExceptionMatches(PyExc_StopIteration))
            goto error;
        else if (tstate->c_tracefunc != NULL)
            call_exc_trace(tstate->c_tracefunc, tstate->c_traceobj, tstate, f);
        PyErr_Clear();
    }
    /* iterator ended normally */
    STACKADJ(-1);
    Py_DECREF(iter);
    JUMPBY(oparg);
    PREDICT(POP_BLOCK);
    DISPATCH();
}

TARGET(BREAK_LOOP) {
    why = WHY_BREAK;
    goto fast_block_end;
}

TARGET(CONTINUE_LOOP) {
    retval = PyLong_FromLong(oparg);
    if (retval == NULL)
        goto error;
    why = WHY_CONTINUE;
    goto fast_block_end;
}

TARGET(SETUP_LOOP)
TARGET(SETUP_EXCEPT)
TARGET(SETUP_FINALLY) {
    /* NOTE: If you add any new block-setup opcodes that
        are not try/except/finally handlers, you may need
        to update the PyGen_NeedsFinalizing() function.
        */

    PyFrame_BlockSetup(f, opcode, INSTR_OFFSET() + oparg,
                        STACK_LEVEL());
    DISPATCH();
}

TARGET(BEFORE_ASYNC_WITH) {
    _Py_IDENTIFIER(__aexit__);
    _Py_IDENTIFIER(__aenter__);

    PyObject *mgr = TOP();
    PyObject *exit = special_lookup(mgr, &PyId___aexit__),
                *enter;
    PyObject *res;
    if (exit == NULL)
        goto error;
    SET_TOP(exit);
    enter = special_lookup(mgr, &PyId___aenter__);
    Py_DECREF(mgr);
    if (enter == NULL)
        goto error;
    res = PyObject_CallFunctionObjArgs(enter, NULL);
    Py_DECREF(enter);
    if (res == NULL)
        goto error;
    PUSH(res);
    PREDICT(GET_AWAITABLE);
    DISPATCH();
}

TARGET(SETUP_ASYNC_WITH) {
    PyObject *res = POP();
    /* Setup the finally block before pushing the result
        of __aenter__ on the stack. */
    PyFrame_BlockSetup(f, SETUP_FINALLY, INSTR_OFFSET() + oparg,
                        STACK_LEVEL());
    PUSH(res);
    DISPATCH();
}

TARGET(SETUP_WITH) {
    _Py_IDENTIFIER(__exit__);
    _Py_IDENTIFIER(__enter__);
    PyObject *mgr = TOP();
    PyObject *enter = special_lookup(mgr, &PyId___enter__), *exit;
    PyObject *res;
    if (enter == NULL)
        goto error;
    exit = special_lookup(mgr, &PyId___exit__);
    if (exit == NULL) {
        Py_DECREF(enter);
        goto error;
    }
    SET_TOP(exit);
    Py_DECREF(mgr);
    res = PyObject_CallFunctionObjArgs(enter, NULL);
    Py_DECREF(enter);
    if (res == NULL)
        goto error;
    /* Setup the finally block before pushing the result
        of __enter__ on the stack. */
    PyFrame_BlockSetup(f, SETUP_FINALLY, INSTR_OFFSET() + oparg,
                        STACK_LEVEL());

    PUSH(res);
    DISPATCH();
}

TARGET(WITH_CLEANUP_START) {
    /* At the top of the stack are 1-6 values indicating
        how/why we entered the finally clause:
        - TOP = None
        - (TOP, SECOND) = (WHY_{RETURN,CONTINUE}), retval
        - TOP = WHY_*; no retval below it
        - (TOP, SECOND, THIRD) = exc_info()
            (FOURTH, FITH, SIXTH) = previous exception for EXCEPT_HANDLER
        Below them is EXIT, the context.__exit__ bound method.
        In the last case, we must call
            EXIT(TOP, SECOND, THIRD)
        otherwise we must call
            EXIT(None, None, None)

        In the first three cases, we remove EXIT from the
        stack, leaving the rest in the same order.  In the
        fourth case, we shift the bottom 3 values of the
        stack down, and replace the empty spot with NULL.

        In addition, if the stack represents an exception,
        *and* the function call returns a 'true' value, we
        push WHY_SILENCED onto the stack.  END_FINALLY will
        then not re-raise the exception.  (But non-local
        gotos should still be resumed.)
    */

    PyObject *exit_func;
    PyObject *exc = TOP(), *val = Py_None, *tb = Py_None, *res;
    if (exc == Py_None) {
        (void)POP();
        exit_func = TOP();
        SET_TOP(exc);
    }
    else if (PyLong_Check(exc)) {
        STACKADJ(-1);
        switch (PyLong_AsLong(exc)) {
        case WHY_RETURN:
        case WHY_CONTINUE:
            /* Retval in TOP. */
            exit_func = SECOND();
            SET_SECOND(TOP());
            SET_TOP(exc);
            break;
        default:
            exit_func = TOP();
            SET_TOP(exc);
            break;
        }
        exc = Py_None;
    }
    else {
        PyObject *tp2, *exc2, *tb2;
        PyTryBlock *block;
        val = SECOND();
        tb = THIRD();
        tp2 = FOURTH();
        exc2 = PEEK(5);
        tb2 = PEEK(6);
        exit_func = PEEK(7);
        SET_VALUE(7, tb2);
        SET_VALUE(6, exc2);
        SET_VALUE(5, tp2);
        /* UNWIND_EXCEPT_HANDLER will pop this off. */
        SET_FOURTH(NULL);
        /* We just shifted the stack down, so we have
            to tell the except handler block that the
            values are lower than it expects. */
        block = &f->f_blockstack[f->f_iblock - 1];
        assert(block->b_type == EXCEPT_HANDLER);
        block->b_level--;
    }
    /* XXX Not the fastest way to call it... */
    res = PyObject_CallFunctionObjArgs(exit_func, exc, val, tb, NULL);
    Py_DECREF(exit_func);
    if (res == NULL)
        goto error;

    Py_INCREF(exc); /* Duplicating the exception on the stack */
    PUSH(exc);
    PUSH(res);
    PREDICT(WITH_CLEANUP_FINISH);
    DISPATCH();
}

PREDICTED(WITH_CLEANUP_FINISH);
TARGET(WITH_CLEANUP_FINISH) {
    PyObject *res = POP();
    PyObject *exc = POP();
    int err;

    if (exc != Py_None)
        err = PyObject_IsTrue(res);
    else
        err = 0;

    Py_DECREF(res);
    Py_DECREF(exc);

    if (err < 0)
        goto error;
    else if (err > 0) {
        err = 0;
        /* There was an exception and a True return */
        PUSH(PyLong_FromLong((long) WHY_SILENCED));
    }
    PREDICT(END_FINALLY);
    DISPATCH();
}

PREDICTED(CALL_FUNCTION);
TARGET(CALL_FUNCTION) {
    PyObject **sp, *res;
    PCALL(PCALL_ALL);
    sp = stack_pointer;
    res = call_function(&sp, oparg, NULL);
    stack_pointer = sp;
    PUSH(res);
    if (res == NULL) {
        goto error;
    }
    DISPATCH();
}

TARGET(CALL_FUNCTION_KW) {
    PyObject **sp, *res, *names;

    names = POP();
    // 56   LOAD_CONST   8 (('c', 'd'))
    // 这里的names是一个元组
    assert(PyTuple_CheckExact(names) && PyTuple_GET_SIZE(names) <= oparg);
    PCALL(PCALL_ALL);
    sp = stack_pointer;
    res = call_function(&sp, oparg, names);
    stack_pointer = sp;
    PUSH(res);
    Py_DECREF(names);

    if (res == NULL) {
        goto error;
    }
    DISPATCH();
}

TARGET(CALL_FUNCTION_EX) {
    PyObject *func, *callargs, *kwargs = NULL, *result;
    PCALL(PCALL_ALL);
    if (oparg & 0x01) {
        kwargs = POP();
        if (!PyDict_CheckExact(kwargs)) {
            PyObject *d = PyDict_New();
            if (d == NULL)
                goto error;
            if (PyDict_Update(d, kwargs) != 0) {
                Py_DECREF(d);
                /* PyDict_Update raises attribute
                    * error (percolated from an attempt
                    * to get 'keys' attribute) instead of
                    * a type error if its second argument
                    * is not a mapping.
                    */
                if (PyErr_ExceptionMatches(PyExc_AttributeError)) {
                    format_kwargs_mapping_error(SECOND(), kwargs);
                }
                Py_DECREF(kwargs);
                goto error;
            }
            Py_DECREF(kwargs);
            kwargs = d;
        }
        assert(PyDict_CheckExact(kwargs));
    }
    callargs = POP();
    func = TOP();
    if (!PyTuple_CheckExact(callargs)) {
        if (check_args_iterable(func, callargs) < 0) {
            Py_DECREF(callargs);
            goto error;
        }
        Py_SETREF(callargs, PySequence_Tuple(callargs));
        if (callargs == NULL) {
            goto error;
        }
    }
    assert(PyTuple_CheckExact(callargs));

    result = do_call_core(func, callargs, kwargs);
    Py_DECREF(func);
    Py_DECREF(callargs);
    Py_XDECREF(kwargs);

    SET_TOP(result);
    if (result == NULL) {
        goto error;
    }
    DISPATCH();
}

TARGET(MAKE_FUNCTION) {
    PyObject *qualname = POP();
    PyObject *codeobj = POP();
    PyFunctionObject *func = (PyFunctionObject *)
        PyFunction_NewWithQualName(codeobj, f->f_globals, qualname);

    Py_DECREF(codeobj);
    Py_DECREF(qualname);
    if (func == NULL) {
        goto error;
    }

    if (oparg & 0x08) {
        assert(PyTuple_CheckExact(TOP()));
        func ->func_closure = POP();
    }
    if (oparg & 0x04) {
        assert(PyDict_CheckExact(TOP()));
        func->func_annotations = POP();
    }
    if (oparg & 0x02) {
        assert(PyDict_CheckExact(TOP()));
        func->func_kwdefaults = POP();
    }
    if (oparg & 0x01) {
        assert(PyTuple_CheckExact(TOP()));
        func->func_defaults = POP();
    }

    PUSH((PyObject *)func);
    DISPATCH();
}

TARGET(BUILD_SLICE) {
    PyObject *start, *stop, *step, *slice;
    if (oparg == 3)
        step = POP();
    else
        step = NULL;
    stop = POP();
    start = TOP();
    slice = PySlice_New(start, stop, step);
    Py_DECREF(start);
    Py_DECREF(stop);
    Py_XDECREF(step);
    SET_TOP(slice);
    if (slice == NULL)
        goto error;
    DISPATCH();
}

TARGET(FORMAT_VALUE) {
    /* Handles f-string value formatting. */
    PyObject *result;
    PyObject *fmt_spec;
    PyObject *value;
    PyObject *(*conv_fn)(PyObject *);
    int which_conversion = oparg & FVC_MASK;
    int have_fmt_spec = (oparg & FVS_MASK) == FVS_HAVE_SPEC;

    fmt_spec = have_fmt_spec ? POP() : NULL;
    value = POP();

    /* See if any conversion is specified. */
    switch (which_conversion) {
    case FVC_STR:   conv_fn = PyObject_Str;   break;
    case FVC_REPR:  conv_fn = PyObject_Repr;  break;
    case FVC_ASCII: conv_fn = PyObject_ASCII; break;

    /* Must be 0 (meaning no conversion), since only four
        values are allowed by (oparg & FVC_MASK). */
    default:        conv_fn = NULL;           break;
    }

    /* If there's a conversion function, call it and replace
        value with that result. Otherwise, just use value,
        without conversion. */
    if (conv_fn != NULL) {
        result = conv_fn(value);
        Py_DECREF(value);
        if (result == NULL) {
            Py_XDECREF(fmt_spec);
            goto error;
        }
        value = result;
    }

    /* If value is a unicode object, and there's no fmt_spec,
        then we know the result of format(value) is value
        itself. In that case, skip calling format(). I plan to
        move this optimization in to PyObject_Format()
        itself. */
    if (PyUnicode_CheckExact(value) && fmt_spec == NULL) {
        /* Do nothing, just transfer ownership to result. */
        result = value;
    } else {
        /* Actually call format(). */
        result = PyObject_Format(value, fmt_spec);
        Py_DECREF(value);
        Py_XDECREF(fmt_spec);
        if (result == NULL) {
            goto error;
        }
    }

    PUSH(result);
    DISPATCH();
}

TARGET(EXTENDED_ARG) {
    int oldoparg = oparg;
    NEXTOPARG();
    oparg |= oldoparg << 8;
    goto dispatch_opcode;
}