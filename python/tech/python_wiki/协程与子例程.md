最近几年，生成器的功能变得越来越强大，它已经被加入到了PEP。在我的下一篇文章中，我会通过协程(coroutine)，协同式多任务处理(cooperative multitasking)，以及异步IO(asynchronous I/O)(尤其是GvR正在研究的 "tulip" 原型的实现)来介绍yield的真正威力。但是在此之前，我们要对生成器和yield有一个扎实的理解.

# 协程与子例程

我们调用一个普通的Python函数时，一般是从函数的第一行代码开始执行，结束于return语句、异常或者函数结束（可以看作隐式的返回None）。一旦函数将控制权交还给调用者，就意味着全部结束。函数中做的所有工作以及保存在局部变量中的数据都将丢失。再次调用这个函数时，一切都将从头创建。 

对于在计算机编程中所讨论的函数，这是很标准的流程。这样的函数只能返回一个值，不过，有时可以创建能产生一个序列的函数还是有帮助的。要做到这一点，这种函数需要能够“保存自己的工作”。 

我说过，能够“产生一个序列”是因为我们的函数并没有像通常意义那样返回。**return隐含的意思是函数正将执行代码的控制权返回给函数被调用的地方**。**而"yield"的隐含意思是控制权的转移是临时和自愿的，我们的函数将来还会收回控制权**

在Python中，拥有这种能力的“函数”被称为**生成器**，它非常的有用。生成器（以及yield语句）最初的引入是为了让程序员可以更简单的编写用来产生值的序列的代码。 以前，要实现类似随机数生成器的东西，需要实现一个类或者一个模块，在生成数据的同时保持对每次调用之间状态的跟踪。引入生成器之后，这变得非常简单。

为了更好的理解生成器所解决的问题，让我们来看一个例子。在了解这个例子的过程中，请始终记住我们需要解决的问题：生成值的序列。

注意：在Python之外，最简单的生成器应该是被称为协程（coroutines）的东西。在本文中，我将使用这个术语。请记住，*在Python的概念中，这里提到的协程就是生成器*。Python正式的术语是生成器；协程只是便于讨论，在语言层面并没有正式定义。

> 在操作系统中,一个线程可以在阻塞的时候,自愿交出cpu资源

## 例子：有趣的素数

假设你的老板让你写一个函数，输入参数是一个int的list，返回一个可以迭代的包含素数1 的结果。

记住，**迭代器（Iterable）** *只是对象每次返回特定成员的一种能力*。

你肯定认为"这很简单"，然后很快写出下面的代码：

```python
def get_primes(input_list):
    result_list = list()
    for element in input_list:
        if is_prime(element):
            result_list.append()

    return result_list

# 或者更好一些的...

def get_primes(input_list):
    return (element for element in input_list if is_prime(element))

# 下面是 is_prime 的一种实现...

def is_prime(number):
    if number > 1:
        if number == 2:
            return True
        if number % 2 == 0:
            return False
        for current in range(3, int(math.sqrt(number) + 1), 2):
            if number % current == 0: 
                return False
        return True
    return False
```

# 处理无限序列

噢，真是如此吗？过了几天，老板过来告诉我们她遇到了一些小问题：她打算把我们的`get_primes`函数用于一个很大的包含数字的list。实际上，这个list非常大，*仅仅是创建这个list就会用完系统的所有内存* 。为此，她希望能够在调用`get_primes`函数时带上一个start参数，返回所有大于这个参数的素数（也许她要解决 Project Euler problem 10）。

我们来看看这个新需求，很明显只是简单的修改get_primes是不可能的。 自然，我们不可能返回包含从start到无穷的所有的素数的列表 (虽然有很多有用的应用程序可以用来操作无限序列)。看上去用普通函数处理这个问题的可能性比较渺茫。

在我们放弃之前，让我们确定一下最核心的障碍，是什么阻止我们编写满足老板新需求的函数。通过思考，我们得到这样的结论：**函数只有一次返回结果的机会，因而必须一次返回所有的结果**。得出这样的结论似乎毫无意义；“函数不就是这样工作的么”，通常我们都这么认为的。可是，不学不成，不问不知，“如果它们并非如此呢？”

想象一下，*如果get_primes可以只是简单返回下一个值，而不是一次返回全部的值*，我们能做什么？我们就不再需要创建列表。没有列表，就没有内存的问题。由于老板告诉我们的是，她只需要遍历结果，她不会知道我们实现上的区别。

# 走进生成器

这类问题极其常见以至于Python专门加入了一个结构来解决它：生成器。一个生成器会“生成”值。创建一个生成器几乎和生成器函数的原理一样简单。

一个生成器函数的定义很像一个普通的函数，除了当它要生成一个值的时候，*使用yield关键字而不是return*。如果一个def的主体包含yield，这个函数会自动变成一个生成器（即使它包含一个return）。除了以上内容，创建一个生成器没有什么多余步骤了。

生成器函数返回生成器的迭代器。这可能是你最后一次见到“生成器的迭代器”这个术语了， 因为它们通常就被称作“生成器”。要注意的是生成器就是一类特殊的迭代器。作为一个迭代器，生成器必须要定义一些方法(method)，其中一个就是`__next__()`。如同迭代器一样，我们可以使用next()函数来获取下一个值。

为了从生成器获取下一个值，我们使用next()函数，就像对付迭代器一样。

(next()会操心如何调用生成器的`__next__()`方法)。既然生成器是一个迭代器，它可以被用在for循环中。

每当生成器被调用的时候，它会返回一个值给调用者。在生成器内部使用yield来完成这个动作(例如yield 7)。为了记住yield到底干了什么，最简单的方法是把它当作专门给生成器函数用的特殊的return(加上点小魔法)。

yield就是专门给生成器用的return(加上点小魔法)。

那么神奇的部分在哪里?我很高兴你问了这个问题!当一个生成器函数调用yield，生成器函数的“状态”会被冻结，所有的变量的值会被保留下来，下一行要执行的代码的位置也会被记录，直到再次调用next()。一旦next()再次被调用，生成器函数会从它上次离开的地方开始。如果永远不调用next()，yield保存的状态就被无视了。

我们来重写`get_primes()`函数，这次我们把它写作一个生成器。注意我们不再需要`magical_infinite_range`函数了。使用一个简单的while循环，我们创造了自己的无穷串列。

```python
def get_primes(number):
    while True:
        if is_prime(number):
            yield number
        number += 1
```
如果生成器函数调用了return，或者执行到函数的末尾，会出现一个StopIteration异常。 这会通知next()的调用者这个生成器没有下一个值了(这就是普通迭代器的行为)。这也是这个while循环在我们的get_primes()函数出现的原因。如果没有这个while，当我们第二次调用next()的时候，生成器函数会执行到函数末尾，触发StopIteration异常。一旦生成器的值用完了，再调用next()就会出现错误，所以你只能将每个生成器的使用一次。
